---
title: JVM面试问题集锦
date: 2021-03-31 22:50:31
tags:
- JVM
- Java
- 面试准备
cover_picture: https://raw.githubusercontent.com/Sunny-Island/Resources/main/images/JVM-cover.jpg
---

前两天字节面试问到了双亲委派机制，我不知道，整理了一些JVM常见问题。

#### 0、为什么要有虚拟机（美团面试）？

java先编译成.class文件，然后交给不同版本的虚拟机运行。其实java只认识JVM，但JVM可以在多个不同平台上运行。实现了code once run everywhere

####  1、介绍JVM的内存区域（运行时数据区）。 ★★ P34

![test](/image/JVM-memory.jpg )

##### 程序计数器：

线程私有，记录每个线程运行的字节码的行号。没有OOM问题

##### 虚拟机栈：

每个线程运行期间自己的栈，用来存储局部变量表（基本数据类型，对象引用）、操作数栈、方法出口等信息，每一个方法被调用就是入栈到出栈的过程。方法出口：正常返回和异常返回。

##### 本地方法栈：

native方法使用的栈，执行java字节码。

##### 堆：

线程共享，GC管理的区域，存放对象实例。堆会被细分位多个线程私有的分配缓冲区，提升分配效率。目的是为了更好回收内存

##### 方法区：

线程共享，存储已经被加载的类型信息、常量、静态变量。可以选择不GC，但并不意味这这是永久区。

运行时常量池：是方法区的一部分。Class文件中有存放编译期生成的各种字面量和符号引用，在类加载后放在方法区的运行时常量池中。具有动态性

#### 2、如何判断对象已经死亡？ ★★P69

##### 引用计数法

维护一个对象的引用计数器，被引用+1，引用失效-1，当归零时意味着对象已经死亡。该方法简单高效但有循环引用问题，比如AB相互引用则AB都不会被GC。java虚拟机并不是采用这种方法来判断对象是否存活的。

##### 可达性分析算法

以GC ROOT对象作为根根据引用关系向下搜索，没有引用链相连的对象判定为不可达。

可以作为GC root：

* 虚拟机栈中各个线程被调用的方法堆栈中使用的参数、局部变量和临时变量等。这意味着他们正在被调用

* 方法区中类静态属性引用的对象，引用类型静态变量

* 方法区中常量引用的对象：比如字符串常量池，初始化字符串时先去常量池中看一下是不是有该字符串，有则返回引用即可

* 本地方法栈中的对象

* java虚拟机内部的对象，比如长用数据类型对应的class，常驻的异常对象等等。

* 所有被同步锁持有的对象

##### 引用类型的分类

传统来说，如果引用指向的地址是另一个内存的起始地址，它就是引用。但有些对象希望尽可能不被收集（缓存功能），只要系统内存还够。因此之后java添加了四种引用

#### 3、简述强、软、弱、虚引用。 ★

* 强引用：传统引用的概念
* 软引用SoftReference如果要OOM了就把这些对象回收了，内存还是不够就OOM
* 弱引用WeakReference。只能生存到下一次GC，如果GC开始工作就会把这部分回收掉
* 虚引用PhantomReference让对象被回收时能收到系统通知。

#### 4、简述垃圾收集算法以及各自特点。 ★★... 25

##### 分代收集假说：

* 老年代的对象大概率不会被回收
* 绝大多数对象很快被回收，新生代的对象大概率（95%）会被回收
* 跨代引用很稀少
##### 标记-清除算法
产生大量的内存碎片，因为需要清除的对象太多导致算法效率很差
##### 标记-复制算法
适合新生代，因为大部分不需要复制。
内存空间分为1个Eden和2个Survivor空间，每次预留空间的10%用作复制用。
存在逃生门的安全设计，如果Survivor空间不够用则会占用老生代的内存空间复制对象
这种机制叫做分配担保
##### 标记-整理算法
适合老年代，100%对象都存活的极限情况。需要移动对象。老年代对象很多负担很大。
移动对象则会导致回收复杂，不移动对象则会使内存分配更复杂，有利于整个程序的吞吐量。 
内存分配的频率比垃圾收集要高得多，因此HotSpot中关注吞吐量的Parallel Old 收集器是标记整理，关注延迟的CMS使用的是多次标记清除知道内存过于碎片化，再用标记整理算法收集一次。


缓存行伪共享问题: https://www.cnblogs.com/cyfonly/p/5800758.html

#### 5、常见的垃圾收集器有哪些。 ★★... 26

不可能三角：内存占用量，吞吐率，延迟
按时间顺序
##### Serial
单线程效率高，新生代，标记-复制，占用内存小，适合在客户端
Serial Old
##### ParNew
Serial 多线程，任需要停止客户端服务
##### CMS
基于标记-清除
实现并发
初始标记 并发标记 重新标记 并发清除，采用增量更新保证并发
容易出现浮动垃圾，运行期间可能导致内存不足，没过N次需要标记整理
##### Parallel Scavenge/Old
关注吞吐量，标记复制-标记整理，争取让代码运行时间更长一些。
##### G1
Region based
复制整理后的Region到新Region
通过STAB实现并发,两个指针TAMS保证新分配的对象
根据优先级队列判断回收哪个region
卡表更加复杂，双向卡表，维护时间长
不会产生内存碎片
可以追求低延迟也可以追求高吞吐量
##### 低延迟：Shenandoah ZGC
通过连接矩阵
通过转发指针和读屏障实现并发
ZGC通过染色指针技术
#### 6、吞吐量优先和响应优先的垃圾收集器如何选择？... 27
吞吐量优先：Parallel Scavenge/Old
响应优先：Shenandoah ZGC
版本问题&&堆内存大小综合考虑：G1 CMS

#### 7、内存分配与回收策略。（对象何时进行老年代？） ★... 27
基于标志-复制算法
优先在Eden区分配 0岁
活过一次GC Survivor 1岁
15岁到老年代，或者动态判定
大对象直接分配到老年代

8、虚拟机性能监控和故障处理工具 ★... 28

9、Class类文件的结构。... 28

10、简述JVM中的类加载机制。★... 28

11、简述JVM中的类加载器以及双亲委派模型。 ★★... 29

12、简述JVM中静态分派和动态分派（重载和重写）。... 30

13、jvm启动模式之client与server（蚂蚁金服）... 30

14、如何优化Java GC（蚂蚁金服） ★... 30

15、JVM进程有哪些线程启动？（拼多多）... 31

16、Java 8的metaspace（元空间）... **31**
