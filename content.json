{"meta":{"title":"赵家贝的博客","subtitle":"","description":"","author":"赵家贝","url":"https://zhaojiabei.ink","root":"/"},"pages":[{"title":"about","date":"2021-11-29T15:41:27.000Z","updated":"2022-04-10T06:56:16.135Z","comments":true,"path":"about/index.html","permalink":"https://zhaojiabei.ink/about/index.html","excerpt":"","text":""},{"title":"test","date":"2021-03-29T09:12:36.000Z","updated":"2022-04-10T06:56:16.139Z","comments":true,"path":"test/index.html","permalink":"https://zhaojiabei.ink/test/index.html","excerpt":"","text":""}],"posts":[{"title":"布隆过滤器","slug":"BigTable论文阅读","date":"2022-04-10T13:24:22.000Z","updated":"2022-04-10T06:56:16.135Z","comments":true,"path":"2022/04/10/BigTable论文阅读/","link":"","permalink":"https://zhaojiabei.ink/2022/04/10/BigTable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"","text":"前言Bigtable是管理大量结构化数据的分布式存储系统。是一个稀疏的、分布式的、持久化存储的多维度排序Map。规模：PB级别数据，数千台机器。性质：广泛应用、可扩展性、高可用，高性能，CAP？不支持传统关系模型，但可以根据数据格式和部署进行动态调整（locality, 相同前缀的数据存在一起，可以做预取优化）。用户可以动态控制何时落盘，何时从磁盘读取。其开源单机实现的版本是著名的leveldb。 数据模型1(row:string, column:string, time:int64) -&gt; string Rows在单个Row下进行的读写保证是原子性的，并发更新行时方便用户编程。排序是通过对行字典序排列的。每一部分行组成tablet，是分布式存储和加载的最小单位。如果只想找几个行，就只需要几台机器的通讯就可以做到。性质相同的数据可以做连续的存储 列族多个列组成的集合叫做列族。列族是访问控制的基本单位，列族层面可以控制、统计磁盘内存使用，上述的控制权限能帮助我们管理不同类型的应用：我们允许一些应用可以添加新的基本数据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数据。表可以有无限多的列，但希望只有上百个列族。同一列族下的数据往往是相同类型的，这样方便压缩。 时间戳表的每一个数据都可以包含不同版本，可以通过配置列族的参数来做GC，制定保留最近的三个版本等等。 实现GFS，分布式文件系统，Bigtable的表存储文件是SSTable格式的，SSTable是持久化的、排序的、不可更改的Map结构，是分块存储的，根据索引可以加载到内存。 Chubby，类似于ZK，Paxos协议，用途： 选主 存储Bigtable自引导 服务发现，服务器上线下线 存储元数据，各个表的列族信息 存储访问控制列表 Tablet 分布Chubby文件，存储root tablet 信息。root tablet，一系列元数据表中的第一个表，存其他元数据表中tablet的位置信息，不会分裂。其他元数据表的tablet。可以索引到用户的tablet。 Tablet 分配客户端直接跟Tablet服务器沟通，绕过master。Chubby 有个文件锁，标志着该tabelt在工作，如果 Tablet 丢失了Chubby上的独占锁，就认为它已经不在工作，master会重新分配。Master可以了解整个集群的数据分布，可以做负载均衡，Tablet分配，服务器加入和推出。Master发现tablet的文件锁被丢失了，就会自己去占领这个锁，判断是Chubby宕机还是服务器宕机。Tablets集合变化：增加删除，合并，分裂。 Master启动：Master获得Master锁，扫描chbby判断服务集群状态，与所有Tablet服务器通信获得Tablet分配的状态。（自引导）。分裂：Tablet表太大或者访问太频繁会导致分裂。首先commit分裂操作到Metadata表中，然后通知master服务器。如果通知没成功，master会要求装载这个的子表，新的Tablet服务器加载子表的时候会查询Metadata表，发现要加载的表信息不完整，会进一步通知master。 Tablet 服务![tablet_server][/image/TabletRepresentation.png]Tablet底层是LSM Tree。可以去看leveldb实现读写操作写入WAL，数据写入内存表memtable，dump到磁盘上，写操作要到Chubby鉴权，会有客户端缓存。提交之后会插入到memtable。读操作要靠合并SSTable和memtable视图，合并效率很高。合并和分割时，读写仍然可以进行。 压缩memtable大小太大时触发压缩变成SSTable。后台有合并压缩进程，定时把SSTable文件删除生成新的压缩文件。叫做主压缩。定期回收内存资源和磁盘资源。","categories":[],"tags":[{"name":"读论文","slug":"读论文","permalink":"https://zhaojiabei.ink/tags/%E8%AF%BB%E8%AE%BA%E6%96%87/"}]},{"title":"九坤并行程序优化大赛第一届经验总结","slug":"九坤并行程序优化大赛第一届经验总结","date":"2022-02-21T20:44:40.000Z","updated":"2022-04-10T06:56:16.135Z","comments":true,"path":"2022/02/21/九坤并行程序优化大赛第一届经验总结/","link":"","permalink":"https://zhaojiabei.ink/2022/02/21/%E4%B9%9D%E5%9D%A4%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E5%A4%A7%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%B1%8A%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/","excerpt":"","text":"赛题背景在赛方给定的服务器上运行winograd算法程序，以每秒浮点数计算量 GFlops 为指标评判。Winograd 算法来⾃于 CVPR 2016 的⼀篇 paper：Fast Algorithms for Convolutional Neural Networks。Winograd 算法的主要思路便是通过减少乘法次数增多加法次数来实现提速。总体上来看这是⼀个计算密集的场景，因⽽优化便在于如果最⼤程度压榨出服务器 CPU 的性能。 服务器环境如下： CPU：Intel(R) Xeon(R) Gold 6348 CPU @ 2.60GHz 内存：768 GB 磁盘：需参照宿主机具体磁盘配置，⽂件系统为 Overlay 在比赛中，我们通过分析算法特点，结合在服务器上的性能试验和队伍成员对体系结构的了解，进行了算法优化、指令级并行、数据级并行、线程级并行、编译器和内存设计等方面的优化，目的是最大限度的压榨 CPU 的运算性能。 算法优化 winograd 的本质是用加法替代乘法，赛方提供的 winograd 算法是基础的 winograd(2,3) ，我们把算法扩展到了 winograd(4,3) ，同时根据2018年更新的文献中的方法，同时合并多个 channel 层进行计算，从而充分利用 CPU 资源。图中的算法分为Input transform、Filter transform、 Matrix Multiplication、Output transform 四个步骤，最大的改进在于同时对多个 channel 层进行分块并在一次矩阵运算中计算，从而充分利用计算能力。 指令级并行在编写代码的时候，我们从循环展开和减少分支预测两方面出发，进行指令级别的并行优化。循环展开主要是在矩阵运算中，因为要把两个固定大小的矩阵相乘，因此把乘法的每一步展开，有利于指令流水线的调度。 数据级并行主要采用向量化的方法，结合算法本身的特性，进行数据级并行优化。单指令流多数据流（SIMD）是能够复制多个操作数，并把它们打包在⼤型寄存器的⼀组指令集。向量化计算是⼀种常⽤于加速计算密集的并⾏任务的优化⽅法。1997 年，x86 扩展出了 MMX 指令集，伴随着 8 个向量寄存器，⾸开了向量化计算的先河。之后 x86 ⼜扩展出了 SSE 和 AVX 指令集。SSE 和 AVX 各有 16 个寄存器，同⼀个寄存器可以装载多个数据单元，并且可以⽤相应的指令在同⼀个时钟周期内进⾏并⾏运算，随着指令集的升级，每个时钟周期可以并⾏的单元数也在不断增加。在我们的服务器和赛⽅提供的服务器上，我们依次实验了 AVX128，AVX256 和 AVX512 指令集，另外还使用了融合乘加指令（FMA）。 线程级并行尝试通过引⼊ openmp 多线程进⾏矩阵运算，但并⾏的性能⼀直不如串⾏，甚⾄经过实验发现有线程数加倍性能减半的现象。经过分析发现在示例代码中有⼤量的⼩矩阵运算，⽐如在第⼀部分逐 channel 逐卷积核的矩阵相乘中有⼤量的⼤⼩为 4 的矩阵，矩阵太⼩导致分给每个线程的任务过少，线程本身的调度开销⼤于多线程带来的收益，因此多线程在这种运算中是⼀种负优化。为了引⼊并⾏加快速度，我们单独为中间的⼤矩阵运算编写了加⼊了多线程的函数，⼩矩阵运算则不加多线程。此优化有近 5 倍的提升。 在之后的优化中，我们放弃了自己编写矩阵乘法，通过调用MKL库来进行大矩阵的乘法操作。 编译器优化以上的⼯作均是在 gcc8 版本上进⾏ O3 优化测得的，⽽ gcc 截⽌今⽇的最新版本已升级为 11.2.0，可以预⻅的是，新版本的 gcc 的调优性能会更突出，为此我们升级到了最新的 gcc 11.2.0 版本并继续⽤ O3 优化进⾏了测试。此⼯作提升了近 10% 的性能。 此外，我们也尝试了最新版本的 Clang/LLVM 编译器，使⽤ O3 版本编译后发现性能甚⾄不如 gcc8。虽然我们的测试不够充分，但我们猜测 LLVM 为了兼容性相⽐ gcc 牺牲调了⼀定的优化空间。就如果 Java 之于 C/C++ ⼀样。 Profile本次比赛中第一次使用 perf 进行调优。通过 perf 可以直观看到代码的各个部分的运行时间，方面我们在比赛中定位瓶颈点。另外 perf 还可以看到缓存命中、流水线停顿等信息，在后期的设计中能给到很多关键的信息。 比赛的不足在这次比赛中我们获得第四名，分析之下除了我们队背景知识薄弱等先天因素之外，对比获得优胜队伍的代码，我总结了这次比赛的不足之处。 放弃编写自己的矩阵乘法，转而调用 MKL 库。因为队伍成员都没有 HPC 项目的经验，因此我们认为不可能编写出比库函数更好的代码。但优胜队伍都自己实现了矩阵乘法，针对这次比赛编写的乘法比我们更高效。 因为没有编写矩阵乘法，我们对缓存的控制也比优胜队伍差很多，没有进行很好的L1、L2、L3级别的缓存设计。虽然我们在内存排布中尽量把会在一次计算中用到的数据放在一起，但如果能做好缓存设计，应该会有更好的成绩。","categories":[],"tags":[{"name":"HPC","slug":"HPC","permalink":"https://zhaojiabei.ink/tags/HPC/"}]},{"title":"布隆过滤器","slug":"布隆过滤器","date":"2021-10-18T20:24:22.000Z","updated":"2022-04-10T06:56:16.135Z","comments":true,"path":"2021/10/18/布隆过滤器/","link":"","permalink":"https://zhaojiabei.ink/2021/10/18/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/","excerpt":"","text":"布隆过滤器布隆过滤器（Bloom Filter）本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0，为了将数据项添加到布隆过滤器中，我们会提供 K 个不同的哈希函数，并将结果位置上对应位的值置为 “1”。在前面所提到的哈希表中，我们使用的是单个哈希函数，因此只能输出单个索引值。而对于布隆过滤器来说，我们将使用多个哈希函数，这将会产生多个索引值。 如果多个哈希值对应的位置都已经被置１，则该元素可能存在于集合中。如果有１位不符合，则说明该元素不在集合中。 布隆过滤器的误判率布隆过滤器的误判率由下列公式给出。据此可以计算最佳函数个数，在保证误判率的情况下，布隆过滤器的位列表长度随需要被过滤的元素正比增加。 资源在线计算网站 https://hur.st/bloomfilter/Java库 Guava https://github.com/google/guava","categories":[],"tags":[{"name":"索引","slug":"索引","permalink":"https://zhaojiabei.ink/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"go sync常用方法","slug":"go-sync常用方法","date":"2021-04-24T01:31:39.000Z","updated":"2022-04-10T06:56:16.135Z","comments":true,"path":"2021/04/24/go-sync常用方法/","link":"","permalink":"https://zhaojiabei.ink/2021/04/24/go-sync%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Mutex WaitGroup Add Done Wait NewCond Wait Broadcast Channel buffer","categories":[],"tags":[{"name":"go","slug":"go","permalink":"https://zhaojiabei.ink/tags/go/"},{"name":"多线程","slug":"多线程","permalink":"https://zhaojiabei.ink/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"VM-MT论文阅读","slug":"VM-MT论文阅读","date":"2021-04-20T01:22:42.000Z","updated":"2022-04-10T06:56:16.135Z","comments":true,"path":"2021/04/20/VM-MT论文阅读/","link":"","permalink":"https://zhaojiabei.ink/2021/04/20/VM-MT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"","text":"The design of a practical system for fault-tolerant virtual machinesreplica 备份方式 传内存块过去：state transfer，以保证state的相同 传操作过去：replicated state machine，使用state transfer Primary/Backup 机器级别vs应用程序级别该论文是在机器指令级别实现主从备份，现在的分布式程序往往在应用程序之间实现备份。 核心思想是让Backup像Primary一样运行，CPU指令级别上的。然后通过对于一些确定的输入，可以确定有相同的运行结果，但是对于一些不确定的事件，比如多核交互（本文只使用单核），指令中断，获取随机数，Backup需要做一些特殊处理，比如拦截中断的指令序列号让其在自己上也在特定的位置中断。 为什么指令中断会影响CPU，因为中断往往来自CPU外部，比如IO设备，时间片到期等等。 中断怎么被复制到Backup上？通过Intel CPU特定的硬件完成。 不能让从机快于主机。 由于VMM会监视输入输出，所以对于Backup机器，其输出不会被返回到客户端，只有在主机失效的时候，根据FT-protocol会切换主备份 FT-Protocol 主机记录自己进行的指令操作，然后发给从机等待执行。从机会放到buffer中去等待执行，这样就防止了从机比主机快。 如果主机fail了，从机直接对外输出 Output requirement如果从机接管了主机，那么从机中已经被传进来的主机指令会继续执行。这样客户端就不会察觉到异常，服务会继续提供。 这条规则是为了保证指令的一致性，如果主机挂掉了，从机会保持和主机一致的行为。 Output rule如果主机执行完就输出了，然后挂掉了，但还没给从机发自己执行过的指令操作，这样也会导致不一致。 因此要求主机先不急着输出自己的执行结果，先把自己的执行指令发给从机并收到了从机的回复，然后再输出结果。 Test and set防止脑裂操作。如果主从机没法互相通信，他们就去外部服务器尝试TEST ANS SET，类似于获得锁，成功set flag的机器将成为主机。","categories":[],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://zhaojiabei.ink/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}]},{"title":"Java面试问题集锦","slug":"Java面试问题集锦","date":"2021-04-14T09:43:24.000Z","updated":"2022-04-10T06:56:16.135Z","comments":true,"path":"2021/04/14/Java面试问题集锦/","link":"","permalink":"https://zhaojiabei.ink/2021/04/14/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/","excerpt":"","text":"前两天面快手问到了Java的Map问题，答得不是很好，正好此博客长期整理各种Java面试问题。 1、Map/HashMap/HashTable/ConcurrentHashMaphttps://blog.csdn.net/woshimaxiao1/article/details/83661464 模拟面试顺序： https://blog.csdn.net/weixin_35523284/article/details/112096437 HashMap线程不安全： https://my.oschina.net/hosee/blog/673521 HashMap细节：https://blog.csdn.net/woshimaxiao1/article/details/83661464","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhaojiabei.ink/tags/Java/"},{"name":"面试准备","slug":"面试准备","permalink":"https://zhaojiabei.ink/tags/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"}]},{"title":"JVM面试问题集锦","slug":"JVM面试问题集锦","date":"2021-03-31T22:50:31.000Z","updated":"2022-04-10T06:56:16.135Z","comments":true,"path":"2021/03/31/JVM面试问题集锦/","link":"","permalink":"https://zhaojiabei.ink/2021/03/31/JVM%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/","excerpt":"","text":"前两天字节面试问到了双亲委派机制，我不知道，整理了一些JVM常见问题。 0、为什么要有虚拟机（美团面试）？java先编译成.class文件，然后交给不同版本的虚拟机运行。其实java只认识JVM，但JVM可以在多个不同平台上运行。实现了code once run everywhere 1、介绍JVM的内存区域（运行时数据区）。 ★★ P34 程序计数器：线程私有，记录每个线程运行的字节码的行号。没有OOM问题 虚拟机栈：每个线程运行期间自己的栈，用来存储局部变量表（基本数据类型，对象引用）、操作数栈、方法出口等信息，每一个方法被调用就是入栈到出栈的过程。方法出口：正常返回和异常返回。 本地方法栈：native方法使用的栈，执行java字节码。 堆：线程共享，GC管理的区域，存放对象实例。堆会被细分位多个线程私有的分配缓冲区，提升分配效率。目的是为了更好回收内存 方法区：线程共享，存储已经被加载的类型信息、常量、静态变量。可以选择不GC，但并不意味这这是永久区。 运行时常量池：是方法区的一部分。Class文件中有存放编译期生成的各种字面量和符号引用，在类加载后放在方法区的运行时常量池中。具有动态性 2、如何判断对象已经死亡？ ★★P69引用计数法维护一个对象的引用计数器，被引用+1，引用失效-1，当归零时意味着对象已经死亡。该方法简单高效但有循环引用问题，比如AB相互引用则AB都不会被GC。java虚拟机并不是采用这种方法来判断对象是否存活的。 可达性分析算法以GC ROOT对象作为根根据引用关系向下搜索，没有引用链相连的对象判定为不可达。 可以作为GC root： 虚拟机栈中各个线程被调用的方法堆栈中使用的参数、局部变量和临时变量等。这意味着他们正在被调用 方法区中类静态属性引用的对象，引用类型静态变量 方法区中常量引用的对象：比如字符串常量池，初始化字符串时先去常量池中看一下是不是有该字符串，有则返回引用即可 本地方法栈中的对象 java虚拟机内部的对象，比如长用数据类型对应的class，常驻的异常对象等等。 所有被同步锁持有的对象 引用类型的分类传统来说，如果引用指向的地址是另一个内存的起始地址，它就是引用。但有些对象希望尽可能不被收集（缓存功能），只要系统内存还够。因此之后java添加了四种引用 3、简述强、软、弱、虚引用。 ★ 强引用：传统引用的概念 软引用SoftReference如果要OOM了就把这些对象回收了，内存还是不够就OOM 弱引用WeakReference。只能生存到下一次GC，如果GC开始工作就会把这部分回收掉 虚引用PhantomReference让对象被回收时能收到系统通知。 4、简述垃圾收集算法以及各自特点。 ★★… 25分代收集假说： 老年代的对象大概率不会被回收 绝大多数对象很快被回收，新生代的对象大概率（95%）会被回收 跨代引用很稀少标记-清除算法产生大量的内存碎片，因为需要清除的对象太多导致算法效率很差标记-复制算法适合新生代，因为大部分不需要复制。内存空间分为1个Eden和2个Survivor空间，每次预留空间的10%用作复制用。存在逃生门的安全设计，如果Survivor空间不够用则会占用老生代的内存空间复制对象这种机制叫做分配担保标记-整理算法适合老年代，100%对象都存活的极限情况。需要移动对象。老年代对象很多负担很大。移动对象则会导致回收复杂，不移动对象则会使内存分配更复杂，有利于整个程序的吞吐量。内存分配的频率比垃圾收集要高得多，因此HotSpot中关注吞吐量的Parallel Old 收集器是标记整理，关注延迟的CMS使用的是多次标记清除知道内存过于碎片化，再用标记整理算法收集一次。 缓存行伪共享问题: https://www.cnblogs.com/cyfonly/p/5800758.html 5、常见的垃圾收集器有哪些。 ★★… 26不可能三角：内存占用量，吞吐率，延迟按时间顺序 Serial单线程效率高，新生代，标记-复制，占用内存小，适合在客户端Serial Old ParNewSerial 多线程，任需要停止客户端服务 CMS基于标记-清除实现并发初始标记 并发标记 重新标记 并发清除，采用增量更新保证并发容易出现浮动垃圾，运行期间可能导致内存不足，没过N次需要标记整理 Parallel Scavenge/Old关注吞吐量，标记复制-标记整理，争取让代码运行时间更长一些。 G1Region based复制整理后的Region到新Region通过STAB实现并发,两个指针TAMS保证新分配的对象根据优先级队列判断回收哪个region卡表更加复杂，双向卡表，维护时间长不会产生内存碎片可以追求低延迟也可以追求高吞吐量 低延迟：Shenandoah ZGC通过连接矩阵通过转发指针和读屏障实现并发ZGC通过染色指针技术 6、吞吐量优先和响应优先的垃圾收集器如何选择？… 27吞吐量优先：Parallel Scavenge/Old响应优先：Shenandoah ZGC版本问题&amp;&amp;堆内存大小综合考虑：G1 CMS 7、内存分配与回收策略。（对象何时进行老年代？） ★… 27基于标志-复制算法优先在Eden区分配 0岁活过一次GC Survivor 1岁15岁到老年代，或者动态判定大对象直接分配到老年代 8、虚拟机性能监控和故障处理工具 ★… 28 9、Class类文件的结构。… 28 10、简述JVM中的类加载机制。★… 28 11、简述JVM中的类加载器以及双亲委派模型。 ★★… 29 12、简述JVM中静态分派和动态分派（重载和重写）。… 30 13、jvm启动模式之client与server（蚂蚁金服）… 30 14、如何优化Java GC（蚂蚁金服） ★… 30 15、JVM进程有哪些线程启动？（拼多多）… 31 16、Java 8的metaspace（元空间）… 31","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zhaojiabei.ink/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zhaojiabei.ink/tags/Java/"},{"name":"面试准备","slug":"面试准备","permalink":"https://zhaojiabei.ink/tags/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"}]},{"title":"CS144笔记(3)","slug":"CS144笔记（3）","date":"2021-03-30T11:01:29.000Z","updated":"2022-04-10T06:56:16.135Z","comments":true,"path":"2021/03/30/CS144笔记（3）/","link":"","permalink":"https://zhaojiabei.ink/2021/03/30/CS144%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/","excerpt":"","text":"TCP可靠的，端到端的传输协议。双向通信=连接。在两端TCP会留下一个状态机。三次握手建立TCPA:SynB:Syn+AckA:AckTCP:stream of bytes serviceA将数据传入TCP segment，B从segment中解析交给应用程序。可能被多次传输。最小1byte比如ssh发送大量数据：填满segment知道最大IP数据包四次挥手关闭TCPTCP的服务特点： Stream of bytes:可靠的字节流传输 Reliable delivery: 收到信息会发送acknowledgments（ack）表示信息已经被接受 checksum校验和检查是否有脏数据（每个segment都有） 序列号检查是否有遗漏数据（segment lost） flow control防止接收方被淹没，接收方有空间则多发，没空间就少发 In sequence: TCP层会对收到的数据进行重新排序使之有序。 Congestion Control 为了实现上述的功能，TCP的header比较复杂。 destination port,source port：把同一台主机的不同TCP连接区分开 sequence number: first byte，下一个number则是上一个number+上一个length acknowledgement sequence: 当前接收到哪个字节 flag位，建立连接和断开会用到ack, fin, syn 等等，还有psh要求立刻发送数据 常见端口号： 21 FTP 22 SSH 23 smtp 80 HTTP 443 HTTPS 1433 MSSQLserver 3306 MySQL 11211 memcached IP中明确告诉我们使用的协议是TCP，通过端口号就可以找到对应的TCP连接。 TCP还有重传，并且利用滑动窗口来做flow control。 UDP应用程序不需要可靠，或者自己处理重传。非常简单。标头只有4个Source port, destination portchecksum,lengthchecksum 包含ip headerUDP信息可能被交付也可能不被交付。UDP的服务特点： 没有连接，数据包传输顺序不确定 不可靠。没有确认，没有探测乱序或者丢失的服务有点像IP的服务。不提供交付保证。应用:DNS,快速高效。 ICMPIP， Routing Tables， ICMP 构成了网络层作错误报告，路由器处理包出了意外，用于向数据源发消息，找出数据包经过的路径。属于传输层协议。不可靠，用于指出问题，不会重发依赖于IP层传输ICMP的一个重要应用：ping，traceroter End to end principle为什么提供这种服务，而不采取更多服务的提供，比如压缩合并文件。 Error Detection校验和 循环冗余码CRC 消息认证码MAC不同层使用不同的方法，结合在一起使得网络的传输错误率非常低。 Checksum不可靠，简单，两个错码可能相互抵消IP/TCP层使用 Cycli redundancy code消耗较大，可以避免很多错误，c位校验码可以检验c位以下的所有错误。在链路层常常使用，可以利用硬件快速计算。 Message authentication code鲁棒性强，可以抵抗恶意信息。TLS层使用（应用层） Finite State Machines比如TCP三次握手的时候会用到。","categories":[],"tags":[{"name":"CS144","slug":"CS144","permalink":"https://zhaojiabei.ink/tags/CS144/"},{"name":"计网","slug":"计网","permalink":"https://zhaojiabei.ink/tags/%E8%AE%A1%E7%BD%91/"},{"name":"TCP","slug":"TCP","permalink":"https://zhaojiabei.ink/tags/TCP/"}]},{"title":"哈希小知识","slug":"哈希小知识","date":"2021-03-13T21:04:20.000Z","updated":"2022-04-10T06:56:16.135Z","comments":true,"path":"2021/03/13/哈希小知识/","link":"","permalink":"https://zhaojiabei.ink/2021/03/13/%E5%93%88%E5%B8%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/","excerpt":"","text":"Hash散列函数为什么要对素数取余假设散列函数是$$hash(key) = key % M= key-xm\\$$假设key和M有公约数g$$key = ag,m =bg\\hash(key)=key-xm = key-[\\frac{a}{b}]m\\0\\le \\frac{a}{b}\\le a$$显然$hash(key)$的取值只有$a+1$种可能，在[0, m-1]上就不是均匀分布了。","categories":[],"tags":[{"name":"Hash","slug":"Hash","permalink":"https://zhaojiabei.ink/tags/Hash/"}]},{"title":"CS144笔记(2)","slug":"CS144笔记（2）","date":"2021-03-12T16:46:31.000Z","updated":"2022-04-10T06:56:16.135Z","comments":true,"path":"2021/03/12/CS144笔记（2）/","link":"","permalink":"https://zhaojiabei.ink/2021/03/12/CS144%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/","excerpt":"","text":"Memory计算机要把信息写到内存中，然后再通过网络发送消息。计算机之间要统一格式，方便阅读这些消息。 Byte OrderLittle endian: 对计算机更有效 Big endian: 方便人类阅读协议选择一个：Internet都选择了Bigendian但是处理器是little endian，很难受host&amp;&amp;network的顺序host和network之间要转换，注意这一点。network选择了Bigendian Packet Formats(IP 网络层)IPV4长度是16，4个16进制数，最长是2^16有目标地址，源地址需要独立的，唯一的地址地址长度32bits，4个八位数字子网掩码：划分网路号和机器号子网掩码前x是1，后32-x是0，对IP地址做与运算，结果相同的是同一个机器同一个IP经过不同的子网掩码会划分出不同的机器号和网络号前缀的设置涉及到子网划分需要的地址块必须是2的整数幂，而且有对其要求（位于字节边界上） 三类地址划分。随着主机增加，这类方法显得很粗糙 CIDR把多个具有相同前缀的地址块聚合成一个大的地址块（路由聚合） 避免了路由信息爆炸。 路由聚合和子网划分可以协同工作。 当一个数据包到达时，路由器做最长前缀匹配，发送。 Longest prefix match路由器选择发送的链路171.33.x.x match 171.33.5.245 and 171.33.1.1如果匹配不到，选择默认链路路由器有转发表，包含CIDR条目和对应的下一跳link/x 越短，匹配的IP范围更广泛 Address Resolution Protocol设备有IP地址，网络层需要通过IP地址找到具体的下一跳的链接地址。IP是网络级地址，link address 描述了特定的网卡，接受链路层的帧。即 以太网地址。购买网卡可以获得唯一的以太网地址。总之就是IP是网络层的，链路层需要自己的具体地址。","categories":[],"tags":[{"name":"CS144","slug":"CS144","permalink":"https://zhaojiabei.ink/tags/CS144/"},{"name":"计网","slug":"计网","permalink":"https://zhaojiabei.ink/tags/%E8%AE%A1%E7%BD%91/"},{"name":"IPv4","slug":"IPv4","permalink":"https://zhaojiabei.ink/tags/IPv4/"}]},{"title":"CS144笔记（1）","slug":"CS144笔记（1）","date":"2021-03-02T15:01:23.000Z","updated":"2022-04-10T06:56:16.135Z","comments":true,"path":"2021/03/02/CS144笔记（1）/","link":"","permalink":"https://zhaojiabei.ink/2021/03/02/CS144%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/","excerpt":"","text":"可靠的双向字节流把计算机通信简化成读、写。 例1：www (http协议) http协议以文件为中心，Clinet向Server发送请求（GET），得到root page和一个状态码（比如200成功码，400失败码） http是人类可以理解的ASCII文本 例2：bit Bit Torrent breaks files into pieces clients join and leave swarms 以种子文件为起点，通过http下载。 描述了tracker的信息 Tracker跟踪所有客户端成员 Client向Tracker请求客户端列表，并向这些客户端请求数据。 Skype NAT:如果你在NAT之后，你可以打开其他连接，但其他Clinet不能随意打开你。个人计算机通常位于NAT之后 集合服务器(Rendezvous) A在NAT后，B不在。B请求rendezvous，rendezvous请求A，A请求B建立连接。最终的结果是A向B发起连接，所以叫反向连接、 中继服务器(Relay) Relay向A和B转发数据。 四层网络模型分层设计思想： - Application - Transport - Network - Link Link 网络组成：links hosts routers 数据链路层的工作是一次通过一个链路传输数据 常见的连接：以太网、wifi 传输帧 Network 最重要的一层 收到Link的信息，并通过router告诉Link下一跳的地址 传输包packet data+header IP(网络层协议) IP协议尽量把数据包传达到另一端,但不保证 IP协议可能会乱序和丢失 需要传输层一起工作保证不出差错 Datagrame 独立传输的数据包，由路由逐步传输 Unreliable 数据包可能被丢失 Best effort 缓存占满时丢弃数据包，错误的路由表导致发送错误(必要情况下才会发生) Connecctionless 不保留连接的状况，不是从建立连接开始的。 Transport TCP:重传,保证数据正确传输 有些不需要TCP(可靠) UDP:不保证可靠传输 Application WEB, http get,直接在应用层使用. 每一层只与另一层通信 IP(网络层协议)- IP协议尽量把数据包传达到另一端,但不保证 - IP协议可能会乱序和丢失 - 需要传输层一起工作保证不出差错 - Datagrame 独立传输的数据包，由路由逐步传输 - Unreliable 数据包可能被丢失 - Best effort 缓存占满时丢弃数据包，错误的路由表导致发送错误(必要情况下才会发生) - Connecctionless 不保留连接的状况，不是从建立连接开始的。 end-to-end principle: 如果可能，尽可能在end hosts处实现功能 IP防止数据包反复循环（路由中的转发表损坏） 报头中，TTL 从128开始，每一跳-1，归零时被路由器丢弃，可能陷入了环路 会对数据包分段，路由器也会根据实际情况拆分数据包 使用header校验和，在报头中。减少传递到错误目的地的机会。 IP有不同的版本 IPV4 32bit， IPV6 128bit IP允许将新字段加到header中。 IPV4 Datagram()版本 区分服务 分段偏移量 校验和 协议 TTL 总长度 源地址 目标地址 TCP协议（传输层）IP找到机器，TCP是找到端口号向特定服务通信的。80端口一般是网页服务 数据包交换原则分层设计原则封装原则 分散了可能存在的隐患 方便复用，各组件单独工作 应用层 message 报文 传输层 TCP segment 报文段 UDP 用户数据段 网络层 IP 数据报 datagram (IPV4 IPV6)，packet（包） 链路层：帧 framing 物理层 bit","categories":[],"tags":[{"name":"CS144","slug":"CS144","permalink":"https://zhaojiabei.ink/tags/CS144/"},{"name":"计网","slug":"计网","permalink":"https://zhaojiabei.ink/tags/%E8%AE%A1%E7%BD%91/"}]}],"categories":[],"tags":[{"name":"读论文","slug":"读论文","permalink":"https://zhaojiabei.ink/tags/%E8%AF%BB%E8%AE%BA%E6%96%87/"},{"name":"HPC","slug":"HPC","permalink":"https://zhaojiabei.ink/tags/HPC/"},{"name":"索引","slug":"索引","permalink":"https://zhaojiabei.ink/tags/%E7%B4%A2%E5%BC%95/"},{"name":"go","slug":"go","permalink":"https://zhaojiabei.ink/tags/go/"},{"name":"多线程","slug":"多线程","permalink":"https://zhaojiabei.ink/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"论文阅读","slug":"论文阅读","permalink":"https://zhaojiabei.ink/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"Java","slug":"Java","permalink":"https://zhaojiabei.ink/tags/Java/"},{"name":"面试准备","slug":"面试准备","permalink":"https://zhaojiabei.ink/tags/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"},{"name":"JVM","slug":"JVM","permalink":"https://zhaojiabei.ink/tags/JVM/"},{"name":"CS144","slug":"CS144","permalink":"https://zhaojiabei.ink/tags/CS144/"},{"name":"计网","slug":"计网","permalink":"https://zhaojiabei.ink/tags/%E8%AE%A1%E7%BD%91/"},{"name":"TCP","slug":"TCP","permalink":"https://zhaojiabei.ink/tags/TCP/"},{"name":"Hash","slug":"Hash","permalink":"https://zhaojiabei.ink/tags/Hash/"},{"name":"IPv4","slug":"IPv4","permalink":"https://zhaojiabei.ink/tags/IPv4/"}]}