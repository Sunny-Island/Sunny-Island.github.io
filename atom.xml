<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵家贝的博客</title>
  
  
  <link href="https://zhaojiabei.ink/atom.xml" rel="self"/>
  
  <link href="https://zhaojiabei.ink/"/>
  <updated>2022-02-21T17:45:03.175Z</updated>
  <id>https://zhaojiabei.ink/</id>
  
  <author>
    <name>赵家贝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="https://zhaojiabei.ink/2021/10/18/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://zhaojiabei.ink/2021/10/18/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2021-10-18T20:24:22.000Z</published>
    <updated>2022-02-21T17:45:03.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器（Bloom Filter）本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0，为了将数据项添加到布隆过滤器中，我们会提供 K 个不同的哈希函数，并将结果位置上对应位的值置为 “1”。在前面所提到的哈希表中，我们使用的是单个哈希函数，因此只能输出单个索引值。而对于布隆过滤器来说，我们将使用多个哈希函数，这将会产生多个索引值。</p><p><img src="/image/bloom_filter.png" alt="test"><br>如果多个哈希值对应的位置都已经被置１，则该元素可能存在于集合中。如果有１位不符合，则说明该元素不在集合中。</p><h3 id="布隆过滤器的误判率"><a href="#布隆过滤器的误判率" class="headerlink" title="布隆过滤器的误判率"></a>布隆过滤器的误判率</h3><p>布隆过滤器的误判率由下列公式给出。<br>据此可以计算最佳函数个数，在保证误判率的情况下，布隆过滤器的位列表长度随需要被过滤的元素正比增加。<br><img src="/image/bf_false_positive.svg" alt="test"></p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>在线计算网站 <a href="https://hur.st/bloomfilter/">https://hur.st/bloomfilter/</a><br>Java库 Guava <a href="https://github.com/google/guava">https://github.com/google/guava</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;布隆过滤器&quot;&gt;&lt;a href=&quot;#布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器&quot;&gt;&lt;/a&gt;布隆过滤器&lt;/h2&gt;&lt;p&gt;布隆过滤器（Bloom Filter）本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，</summary>
      
    
    
    
    
    <category term="索引" scheme="https://zhaojiabei.ink/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>go sync常用方法</title>
    <link href="https://zhaojiabei.ink/2021/04/24/go-sync%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://zhaojiabei.ink/2021/04/24/go-sync%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2021-04-24T01:31:39.000Z</published>
    <updated>2022-02-21T17:45:03.175Z</updated>
    
    <content type="html"><![CDATA[<p>Mutex</p><p>WaitGroup</p><ul><li>Add</li><li>Done</li><li>Wait</li></ul><p>NewCond</p><ul><li>Wait</li><li>Broadcast</li></ul><p>Channel</p><ul><li>buffer</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Mutex&lt;/p&gt;
&lt;p&gt;WaitGroup&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add&lt;/li&gt;
&lt;li&gt;Done&lt;/li&gt;
&lt;li&gt;Wait&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NewCond&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wait&lt;/li&gt;
&lt;li&gt;Broadcast&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    
    <category term="go" scheme="https://zhaojiabei.ink/tags/go/"/>
    
    <category term="多线程" scheme="https://zhaojiabei.ink/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>VM-MT论文阅读</title>
    <link href="https://zhaojiabei.ink/2021/04/20/VM-MT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>https://zhaojiabei.ink/2021/04/20/VM-MT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-04-20T01:22:42.000Z</published>
    <updated>2022-02-21T17:45:03.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-design-of-a-practical-system-for-fault-tolerant-virtual-machines"><a href="#The-design-of-a-practical-system-for-fault-tolerant-virtual-machines" class="headerlink" title="The design of a practical system for fault-tolerant virtual machines"></a>The design of a practical system for fault-tolerant virtual machines</h2><h3 id="replica-备份方式"><a href="#replica-备份方式" class="headerlink" title="replica 备份方式"></a>replica 备份方式</h3><ul><li><p>传内存块过去：state transfer，以保证state的相同</p></li><li><p>传操作过去：replicated state machine，使用state transfer</p></li></ul><p>Primary/Backup</p><h3 id="机器级别vs应用程序级别"><a href="#机器级别vs应用程序级别" class="headerlink" title="机器级别vs应用程序级别"></a>机器级别vs应用程序级别</h3><p>该论文是在机器指令级别实现主从备份，现在的分布式程序往往在应用程序之间实现备份。</p><p>核心思想是让Backup像Primary一样运行，CPU指令级别上的。然后通过对于一些确定的输入，可以确定有相同的运行结果，但是对于一些不确定的事件，比如多核交互（本文只使用单核），指令中断，获取随机数，Backup需要做一些特殊处理，比如拦截中断的指令序列号让其在自己上也在特定的位置中断。</p><p>为什么指令中断会影响CPU，因为中断往往来自CPU外部，比如IO设备，时间片到期等等。</p><p>中断怎么被复制到Backup上？通过Intel CPU特定的硬件完成。</p><p>不能让从机快于主机。</p><p>由于VMM会监视输入输出，所以对于Backup机器，其输出不会被返回到客户端，只有在主机失效的时候，根据FT-protocol会切换主备份</p><h3 id="FT-Protocol"><a href="#FT-Protocol" class="headerlink" title="FT-Protocol"></a>FT-Protocol</h3><p><img src="/image/vm-ft.jpg" alt="test"></p><p>主机记录自己进行的指令操作，然后发给从机等待执行。从机会放到buffer中去等待执行，这样就防止了从机比主机快。</p><p>如果主机fail了，从机直接对外输出</p><h5 id="Output-requirement"><a href="#Output-requirement" class="headerlink" title="Output requirement"></a>Output requirement</h5><p>如果从机接管了主机，那么从机中已经被传进来的主机指令会继续执行。这样客户端就不会察觉到异常，服务会继续提供。</p><p>这条规则是为了保证指令的一致性，如果主机挂掉了，从机会保持和主机一致的行为。</p><h5 id="Output-rule"><a href="#Output-rule" class="headerlink" title="Output rule"></a>Output rule</h5><p>如果主机执行完就输出了，然后挂掉了，但还没给从机发自己执行过的指令操作，这样也会导致不一致。</p><p>因此要求主机先不急着输出自己的执行结果，先把自己的执行指令发给从机并收到了从机的回复，然后再输出结果。</p><h5 id="Test-and-set"><a href="#Test-and-set" class="headerlink" title="Test and set"></a>Test and set</h5><p>防止脑裂操作。如果主从机没法互相通信，他们就去外部服务器尝试TEST ANS SET，类似于获得锁，成功set flag的机器将成为主机。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-design-of-a-practical-system-for-fault-tolerant-virtual-machines&quot;&gt;&lt;a href=&quot;#The-design-of-a-practical-system-for-fault-tolerant-</summary>
      
    
    
    
    
    <category term="论文阅读" scheme="https://zhaojiabei.ink/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java面试问题集锦</title>
    <link href="https://zhaojiabei.ink/2021/04/14/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>https://zhaojiabei.ink/2021/04/14/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</id>
    <published>2021-04-14T09:43:24.000Z</published>
    <updated>2022-02-21T17:45:03.175Z</updated>
    
    <content type="html"><![CDATA[<p>前两天面快手问到了Java的Map问题，答得不是很好，正好此博客长期整理各种Java面试问题。</p><h4 id="1、Map-HashMap-HashTable-ConcurrentHashMap"><a href="#1、Map-HashMap-HashTable-ConcurrentHashMap" class="headerlink" title="1、Map/HashMap/HashTable/ConcurrentHashMap"></a>1、Map/HashMap/HashTable/ConcurrentHashMap</h4><p><a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464">https://blog.csdn.net/woshimaxiao1/article/details/83661464</a></p><p>模拟面试顺序： <a href="https://blog.csdn.net/weixin_35523284/article/details/112096437">https://blog.csdn.net/weixin_35523284/article/details/112096437</a></p><p>HashMap线程不安全： <a href="https://my.oschina.net/hosee/blog/673521">https://my.oschina.net/hosee/blog/673521</a></p><p>HashMap细节：<a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464">https://blog.csdn.net/woshimaxiao1/article/details/83661464</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前两天面快手问到了Java的Map问题，答得不是很好，正好此博客长期整理各种Java面试问题。&lt;/p&gt;
&lt;h4 id=&quot;1、Map-HashMap-HashTable-ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#1、Map-HashMap-HashTable-</summary>
      
    
    
    
    
    <category term="Java" scheme="https://zhaojiabei.ink/tags/Java/"/>
    
    <category term="面试准备" scheme="https://zhaojiabei.ink/tags/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>JVM面试问题集锦</title>
    <link href="https://zhaojiabei.ink/2021/03/31/JVM%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>https://zhaojiabei.ink/2021/03/31/JVM%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</id>
    <published>2021-03-31T22:50:31.000Z</published>
    <updated>2022-02-21T17:45:03.175Z</updated>
    
    <content type="html"><![CDATA[<p>前两天字节面试问到了双亲委派机制，我不知道，整理了一些JVM常见问题。</p><h4 id="0、为什么要有虚拟机（美团面试）？"><a href="#0、为什么要有虚拟机（美团面试）？" class="headerlink" title="0、为什么要有虚拟机（美团面试）？"></a>0、为什么要有虚拟机（美团面试）？</h4><p>java先编译成.class文件，然后交给不同版本的虚拟机运行。其实java只认识JVM，但JVM可以在多个不同平台上运行。实现了code once run everywhere</p><h4 id="1、介绍JVM的内存区域（运行时数据区）。-★★-P34"><a href="#1、介绍JVM的内存区域（运行时数据区）。-★★-P34" class="headerlink" title="1、介绍JVM的内存区域（运行时数据区）。 ★★ P34"></a>1、介绍JVM的内存区域（运行时数据区）。 ★★ P34</h4><p><img src="/image/JVM-memory.jpg" alt="test"></p><h5 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h5><p>线程私有，记录每个线程运行的字节码的行号。没有OOM问题</p><h5 id="虚拟机栈："><a href="#虚拟机栈：" class="headerlink" title="虚拟机栈："></a>虚拟机栈：</h5><p>每个线程运行期间自己的栈，用来存储局部变量表（基本数据类型，对象引用）、操作数栈、方法出口等信息，每一个方法被调用就是入栈到出栈的过程。方法出口：正常返回和异常返回。</p><h5 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h5><p>native方法使用的栈，执行java字节码。</p><h5 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h5><p>线程共享，GC管理的区域，存放对象实例。堆会被细分位多个线程私有的分配缓冲区，提升分配效率。目的是为了更好回收内存</p><h5 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h5><p>线程共享，存储已经被加载的类型信息、常量、静态变量。可以选择不GC，但并不意味这这是永久区。</p><p>运行时常量池：是方法区的一部分。Class文件中有存放编译期生成的各种字面量和符号引用，在类加载后放在方法区的运行时常量池中。具有动态性</p><h4 id="2、如何判断对象已经死亡？-★★P69"><a href="#2、如何判断对象已经死亡？-★★P69" class="headerlink" title="2、如何判断对象已经死亡？ ★★P69"></a>2、如何判断对象已经死亡？ ★★P69</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>维护一个对象的引用计数器，被引用+1，引用失效-1，当归零时意味着对象已经死亡。该方法简单高效但有循环引用问题，比如AB相互引用则AB都不会被GC。java虚拟机并不是采用这种方法来判断对象是否存活的。</p><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>以GC ROOT对象作为根根据引用关系向下搜索，没有引用链相连的对象判定为不可达。</p><p>可以作为GC root：</p><ul><li><p>虚拟机栈中各个线程被调用的方法堆栈中使用的参数、局部变量和临时变量等。这意味着他们正在被调用</p></li><li><p>方法区中类静态属性引用的对象，引用类型静态变量</p></li><li><p>方法区中常量引用的对象：比如字符串常量池，初始化字符串时先去常量池中看一下是不是有该字符串，有则返回引用即可</p></li><li><p>本地方法栈中的对象</p></li><li><p>java虚拟机内部的对象，比如长用数据类型对应的class，常驻的异常对象等等。</p></li><li><p>所有被同步锁持有的对象</p></li></ul><h5 id="引用类型的分类"><a href="#引用类型的分类" class="headerlink" title="引用类型的分类"></a>引用类型的分类</h5><p>传统来说，如果引用指向的地址是另一个内存的起始地址，它就是引用。但有些对象希望尽可能不被收集（缓存功能），只要系统内存还够。因此之后java添加了四种引用</p><h4 id="3、简述强、软、弱、虚引用。-★"><a href="#3、简述强、软、弱、虚引用。-★" class="headerlink" title="3、简述强、软、弱、虚引用。 ★"></a>3、简述强、软、弱、虚引用。 ★</h4><ul><li>强引用：传统引用的概念</li><li>软引用SoftReference如果要OOM了就把这些对象回收了，内存还是不够就OOM</li><li>弱引用WeakReference。只能生存到下一次GC，如果GC开始工作就会把这部分回收掉</li><li>虚引用PhantomReference让对象被回收时能收到系统通知。</li></ul><h4 id="4、简述垃圾收集算法以及各自特点。-★★…-25"><a href="#4、简述垃圾收集算法以及各自特点。-★★…-25" class="headerlink" title="4、简述垃圾收集算法以及各自特点。 ★★… 25"></a>4、简述垃圾收集算法以及各自特点。 ★★… 25</h4><h5 id="分代收集假说："><a href="#分代收集假说：" class="headerlink" title="分代收集假说："></a>分代收集假说：</h5><ul><li>老年代的对象大概率不会被回收</li><li>绝大多数对象很快被回收，新生代的对象大概率（95%）会被回收</li><li>跨代引用很稀少<h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5>产生大量的内存碎片，因为需要清除的对象太多导致算法效率很差<h5 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h5>适合新生代，因为大部分不需要复制。<br>内存空间分为1个Eden和2个Survivor空间，每次预留空间的10%用作复制用。<br>存在逃生门的安全设计，如果Survivor空间不够用则会占用老生代的内存空间复制对象<br>这种机制叫做分配担保<h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5>适合老年代，100%对象都存活的极限情况。需要移动对象。老年代对象很多负担很大。<br>移动对象则会导致回收复杂，不移动对象则会使内存分配更复杂，有利于整个程序的吞吐量。<br>内存分配的频率比垃圾收集要高得多，因此HotSpot中关注吞吐量的Parallel Old 收集器是标记整理，关注延迟的CMS使用的是多次标记清除知道内存过于碎片化，再用标记整理算法收集一次。</li></ul><p>缓存行伪共享问题: <a href="https://www.cnblogs.com/cyfonly/p/5800758.html">https://www.cnblogs.com/cyfonly/p/5800758.html</a></p><h4 id="5、常见的垃圾收集器有哪些。-★★…-26"><a href="#5、常见的垃圾收集器有哪些。-★★…-26" class="headerlink" title="5、常见的垃圾收集器有哪些。 ★★… 26"></a>5、常见的垃圾收集器有哪些。 ★★… 26</h4><p>不可能三角：内存占用量，吞吐率，延迟<br>按时间顺序</p><h5 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h5><p>单线程效率高，新生代，标记-复制，占用内存小，适合在客户端<br>Serial Old</p><h5 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h5><p>Serial 多线程，任需要停止客户端服务</p><h5 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h5><p>基于标记-清除<br>实现并发<br>初始标记 并发标记 重新标记 并发清除，采用增量更新保证并发<br>容易出现浮动垃圾，运行期间可能导致内存不足，没过N次需要标记整理</p><h5 id="Parallel-Scavenge-Old"><a href="#Parallel-Scavenge-Old" class="headerlink" title="Parallel Scavenge/Old"></a>Parallel Scavenge/Old</h5><p>关注吞吐量，标记复制-标记整理，争取让代码运行时间更长一些。</p><h5 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h5><p>Region based<br>复制整理后的Region到新Region<br>通过STAB实现并发,两个指针TAMS保证新分配的对象<br>根据优先级队列判断回收哪个region<br>卡表更加复杂，双向卡表，维护时间长<br>不会产生内存碎片<br>可以追求低延迟也可以追求高吞吐量</p><h5 id="低延迟：Shenandoah-ZGC"><a href="#低延迟：Shenandoah-ZGC" class="headerlink" title="低延迟：Shenandoah ZGC"></a>低延迟：Shenandoah ZGC</h5><p>通过连接矩阵<br>通过转发指针和读屏障实现并发<br>ZGC通过染色指针技术</p><h4 id="6、吞吐量优先和响应优先的垃圾收集器如何选择？…-27"><a href="#6、吞吐量优先和响应优先的垃圾收集器如何选择？…-27" class="headerlink" title="6、吞吐量优先和响应优先的垃圾收集器如何选择？… 27"></a>6、吞吐量优先和响应优先的垃圾收集器如何选择？… 27</h4><p>吞吐量优先：Parallel Scavenge/Old<br>响应优先：Shenandoah ZGC<br>版本问题&amp;&amp;堆内存大小综合考虑：G1 CMS</p><h4 id="7、内存分配与回收策略。（对象何时进行老年代？）-★…-27"><a href="#7、内存分配与回收策略。（对象何时进行老年代？）-★…-27" class="headerlink" title="7、内存分配与回收策略。（对象何时进行老年代？） ★… 27"></a>7、内存分配与回收策略。（对象何时进行老年代？） ★… 27</h4><p>基于标志-复制算法<br>优先在Eden区分配 0岁<br>活过一次GC Survivor 1岁<br>15岁到老年代，或者动态判定<br>大对象直接分配到老年代</p><p>8、虚拟机性能监控和故障处理工具 ★… 28</p><p>9、Class类文件的结构。… 28</p><p>10、简述JVM中的类加载机制。★… 28</p><p>11、简述JVM中的类加载器以及双亲委派模型。 ★★… 29</p><p>12、简述JVM中静态分派和动态分派（重载和重写）。… 30</p><p>13、jvm启动模式之client与server（蚂蚁金服）… 30</p><p>14、如何优化Java GC（蚂蚁金服） ★… 30</p><p>15、JVM进程有哪些线程启动？（拼多多）… 31</p><p>16、Java 8的metaspace（元空间）… <strong>31</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前两天字节面试问到了双亲委派机制，我不知道，整理了一些JVM常见问题。&lt;/p&gt;
&lt;h4 id=&quot;0、为什么要有虚拟机（美团面试）？&quot;&gt;&lt;a href=&quot;#0、为什么要有虚拟机（美团面试）？&quot; class=&quot;headerlink&quot; title=&quot;0、为什么要有虚拟机（美团面试</summary>
      
    
    
    
    
    <category term="JVM" scheme="https://zhaojiabei.ink/tags/JVM/"/>
    
    <category term="Java" scheme="https://zhaojiabei.ink/tags/Java/"/>
    
    <category term="面试准备" scheme="https://zhaojiabei.ink/tags/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>CS144笔记(3)</title>
    <link href="https://zhaojiabei.ink/2021/03/30/CS144%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <id>https://zhaojiabei.ink/2021/03/30/CS144%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/</id>
    <published>2021-03-30T11:01:29.000Z</published>
    <updated>2022-02-21T17:45:03.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>可靠的，端到端的传输协议。<br>双向通信=连接。在两端TCP会留下一个状态机。<br>三次握手建立TCP<br>A:Syn<br>B:Syn+Ack<br>A:Ack<br>TCP:stream of bytes service<br>A将数据传入TCP segment，B从segment中解析交给应用程序。<br>可能被多次传输。<br>最小1byte比如ssh<br>发送大量数据：填满segment知道最大IP数据包<br>四次挥手关闭TCP<br>TCP的服务特点：</p><ul><li><p>Stream of bytes:可靠的字节流传输</p></li><li><p>Reliable delivery:</p><ul><li>收到信息会发送acknowledgments（ack）表示信息已经被接受</li><li>checksum校验和检查是否有脏数据（每个segment都有）</li><li>序列号检查是否有遗漏数据（segment lost）</li><li>flow control防止接收方被淹没，接收方有空间则多发，没空间就少发</li></ul></li><li><p>In sequence: TCP层会对收到的数据进行重新排序使之有序。</p></li><li><p>Congestion Control</p></li></ul><p>为了实现上述的功能，TCP的header比较复杂。</p><p>destination port,source port：把同一台主机的不同TCP连接区分开</p><p>sequence number: first byte，下一个number则是上一个number+上一个length</p><p>acknowledgement sequence: 当前接收到哪个字节</p><p>flag位，建立连接和断开会用到ack, fin, syn 等等，还有psh要求立刻发送数据</p><p>常见端口号：</p><p>21 FTP</p><p>22 SSH</p><p>23 smtp</p><p>80 HTTP</p><p>443 HTTPS</p><p>1433 MSSQLserver</p><p>3306 MySQL</p><p>11211 memcached</p><p>IP中明确告诉我们使用的协议是TCP，通过端口号就可以找到对应的TCP连接。</p><p>TCP还有重传，并且利用滑动窗口来做flow control。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>应用程序不需要可靠，或者自己处理重传。<br>非常简单。标头只有4个<br>Source port, destination port<br>checksum,length<br>checksum 包含ip header<br>UDP信息可能被交付也可能不被交付。<br>UDP的服务特点：</p><ul><li><p>没有连接，数据包传输顺序不确定</p></li><li><p>不可靠。没有确认，没有探测乱序或者丢失的服务<br>有点像IP的服务。不提供交付保证。<br>应用:DNS,快速高效。</p></li></ul><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>IP， Routing Tables， ICMP 构成了网络层<br>作错误报告，路由器处理包出了意外，用于向数据源发消息，找出数据包经过的路径。<br>属于传输层协议。<br>不可靠，用于指出问题，不会重发<br>依赖于IP层传输<br>ICMP的一个重要应用：ping，traceroter</p><h2 id="End-to-end-principle"><a href="#End-to-end-principle" class="headerlink" title="End to end principle"></a>End to end principle</h2><p>为什么提供这种服务，而不采取更多服务的提供，比如压缩合并文件。</p><h2 id="Error-Detection"><a href="#Error-Detection" class="headerlink" title="Error Detection"></a>Error Detection</h2><p>校验和 循环冗余码CRC 消息认证码MAC<br>不同层使用不同的方法，结合在一起使得网络的传输错误率非常低。</p><h3 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h3><p>不可靠，简单，两个错码可能相互抵消<br>IP/TCP层使用</p><h3 id="Cycli-redundancy-code"><a href="#Cycli-redundancy-code" class="headerlink" title="Cycli redundancy code"></a>Cycli redundancy code</h3><p>消耗较大，可以避免很多错误，c位校验码可以检验c位以下的所有错误。<br>在链路层常常使用，可以利用硬件快速计算。</p><h3 id="Message-authentication-code"><a href="#Message-authentication-code" class="headerlink" title="Message authentication code"></a>Message authentication code</h3><p>鲁棒性强，可以抵抗恶意信息。<br>TLS层使用（应用层）</p><h2 id="Finite-State-Machines"><a href="#Finite-State-Machines" class="headerlink" title="Finite State Machines"></a>Finite State Machines</h2><p>比如TCP三次握手的时候会用到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;TCP&quot;&gt;&lt;/a&gt;TCP&lt;/h2&gt;&lt;p&gt;可靠的，端到端的传输协议。&lt;br&gt;双向通信=连接。在两端TCP会留下一个状态机。&lt;br&gt;三次握手建立TCP&lt;br&gt;A:Syn&lt;br&gt;</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://zhaojiabei.ink/tags/CS144/"/>
    
    <category term="计网" scheme="https://zhaojiabei.ink/tags/%E8%AE%A1%E7%BD%91/"/>
    
    <category term="TCP" scheme="https://zhaojiabei.ink/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>哈希小知识</title>
    <link href="https://zhaojiabei.ink/2021/03/13/%E5%93%88%E5%B8%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>https://zhaojiabei.ink/2021/03/13/%E5%93%88%E5%B8%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/</id>
    <published>2021-03-13T21:04:20.000Z</published>
    <updated>2022-02-21T17:45:03.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hash散列函数为什么要对素数取余"><a href="#Hash散列函数为什么要对素数取余" class="headerlink" title="Hash散列函数为什么要对素数取余"></a>Hash散列函数为什么要对素数取余</h3><p>假设散列函数是<br>$$<br>hash(key) = key % M= key-xm\<br>$$<br>假设key和M有公约数g<br>$$<br>key = ag,m =bg\<br>hash(key)=key-xm = key-[\frac{a}{b}]m\<br>0\le \frac{a}{b}\le a<br>$$<br>显然$hash(key)$的取值只有$a+1$种可能，在[0, m-1]上就不是均匀分布了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Hash散列函数为什么要对素数取余&quot;&gt;&lt;a href=&quot;#Hash散列函数为什么要对素数取余&quot; class=&quot;headerlink&quot; title=&quot;Hash散列函数为什么要对素数取余&quot;&gt;&lt;/a&gt;Hash散列函数为什么要对素数取余&lt;/h3&gt;&lt;p&gt;假设散列函数是&lt;br</summary>
      
    
    
    
    
    <category term="Hash" scheme="https://zhaojiabei.ink/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>CS144笔记(2)</title>
    <link href="https://zhaojiabei.ink/2021/03/12/CS144%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>https://zhaojiabei.ink/2021/03/12/CS144%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</id>
    <published>2021-03-12T16:46:31.000Z</published>
    <updated>2022-02-21T17:45:03.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>计算机要把信息写到内存中，然后再通过网络发送消息。计算机之间要统一格式，方便阅读这些消息。</p><h3 id="Byte-Order"><a href="#Byte-Order" class="headerlink" title="Byte Order"></a>Byte Order</h3><p>Little endian: 对计算机更有效</p><p>Big endian: 方便人类阅读<br>协议选择一个：Internet都选择了Bigendian<br>但是处理器是little endian，很难受<br>host&amp;&amp;network的顺序<br>host和network之间要转换，注意这一点。network选择了Bigendian</p><h3 id="Packet-Formats-IP-网络层"><a href="#Packet-Formats-IP-网络层" class="headerlink" title="Packet Formats(IP 网络层)"></a>Packet Formats(IP 网络层)</h3><p>IPV4长度是16，4个16进制数，最长是2^16<br>有目标地址，源地址<br>需要独立的，唯一的地址<br>地址长度32bits，4个八位数字<br>子网掩码：划分网路号和机器号<br>子网掩码前x是1，后32-x是0，对IP地址做与运算，结果相同的是同一个机器<br>同一个IP经过不同的子网掩码会划分出不同的机器号和网络号<br>前缀的设置涉及到子网划分<br>需要的地址块必须是2的整数幂，而且有对其要求（位于字节边界上）</p><p>三类地址划分。随着主机增加，这类方法显得很粗糙</p><h4 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h4><p>把多个具有相同前缀的地址块聚合成一个大的地址块（路由聚合）</p><p>避免了路由信息爆炸。</p><p>路由聚合和子网划分可以协同工作。</p><p>当一个数据包到达时，路由器做最长前缀匹配，发送。</p><h4 id="Longest-prefix-match"><a href="#Longest-prefix-match" class="headerlink" title="Longest prefix match"></a>Longest prefix match</h4><p>路由器选择发送的链路<br>171.33.x.x match 171.33.5.245 and 171.33.1.1<br>如果匹配不到，选择默认链路<br>路由器有转发表，包含CIDR条目和对应的下一跳link<br>/x 越短，匹配的IP范围更广泛</p><h4 id="Address-Resolution-Protocol"><a href="#Address-Resolution-Protocol" class="headerlink" title="Address Resolution Protocol"></a>Address Resolution Protocol</h4><p>设备有IP地址，网络层需要通过IP地址找到具体的下一跳的链接地址。IP是网络级地址，link address 描述了特定的网卡，接受链路层的帧。即 以太网地址。<br>购买网卡可以获得唯一的以太网地址。<br>总之就是IP是网络层的，链路层需要自己的具体地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Memory&quot;&gt;&lt;a href=&quot;#Memory&quot; class=&quot;headerlink&quot; title=&quot;Memory&quot;&gt;&lt;/a&gt;Memory&lt;/h3&gt;&lt;p&gt;计算机要把信息写到内存中，然后再通过网络发送消息。计算机之间要统一格式，方便阅读这些消息。&lt;/p&gt;
&lt;h3 </summary>
      
    
    
    
    
    <category term="CS144" scheme="https://zhaojiabei.ink/tags/CS144/"/>
    
    <category term="计网" scheme="https://zhaojiabei.ink/tags/%E8%AE%A1%E7%BD%91/"/>
    
    <category term="IPv4" scheme="https://zhaojiabei.ink/tags/IPv4/"/>
    
  </entry>
  
  <entry>
    <title>CS144笔记（1）</title>
    <link href="https://zhaojiabei.ink/2021/03/02/CS144%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://zhaojiabei.ink/2021/03/02/CS144%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
    <published>2021-03-02T15:01:23.000Z</published>
    <updated>2022-02-21T17:45:03.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可靠的双向字节流"><a href="#可靠的双向字节流" class="headerlink" title="可靠的双向字节流"></a>可靠的双向字节流</h2><p>把计算机通信简化成读、写。</p><h4 id="例1：www-http协议"><a href="#例1：www-http协议" class="headerlink" title="例1：www (http协议)"></a>例1：www (http协议)</h4><ul><li>http协议以文件为中心，Clinet向Server发送请求（GET），得到root page和一个状态码（比如200成功码，400失败码）</li><li>http是人类可以理解的ASCII文本</li></ul><h4 id="例2：bit"><a href="#例2：bit" class="headerlink" title="例2：bit"></a>例2：bit</h4><ul><li><p>Bit Torrent breaks files into pieces</p></li><li><p>clients join and leave swarms</p></li><li><p>以<strong>种子</strong>文件为起点，通过http下载。</p><ul><li>描述了tracker的信息</li></ul></li><li><p>Tracker跟踪所有客户端成员</p></li><li><p>Client向Tracker请求客户端列表，并向这些客户端请求数据。</p></li></ul><h4 id="Skype"><a href="#Skype" class="headerlink" title="Skype"></a>Skype</h4><ul><li>NAT:如果你在NAT之后，你可以打开其他连接，但其他Clinet不能随意打开你。个人计算机通常位于NAT之后</li><li>集合服务器(Rendezvous)<ul><li>A在NAT后，B不在。B请求rendezvous，rendezvous请求A，A请求B建立连接。最终的结果是A向B发起连接，所以叫反向连接、</li></ul></li><li>中继服务器(Relay)<ul><li>Relay向A和B转发数据。</li></ul></li></ul><h2 id="四层网络模型"><a href="#四层网络模型" class="headerlink" title="四层网络模型"></a>四层网络模型</h2><p>分层设计思想：<br>    - Application<br>    - Transport<br>    - Network<br>    - Link</p><ul><li><p>Link</p><ul><li><pre><code>网络组成：links hosts routers</code></pre></li><li><pre><code>数据链路层的工作是一次通过一个链路传输数据</code></pre></li><li><pre><code>常见的连接：以太网、wifi</code></pre></li><li><pre><code>传输帧</code></pre></li></ul></li><li><p>Network</p><ul><li>最重要的一层</li><li>收到Link的信息，并通过router告诉Link下一跳的地址</li><li>传输包packet data+header</li></ul></li><li><p>IP(网络层协议)</p><ul><li><p>IP协议尽量把数据包传达到另一端,但不保证</p></li><li><p>IP协议可能会乱序和丢失</p><ul><li>需要传输层一起工作保证不出差错</li></ul></li><li><p>Datagrame 独立传输的数据包，由路由逐步传输</p></li><li><p>Unreliable 数据包可能被丢失</p></li><li><p>Best effort 缓存占满时丢弃数据包，错误的路由表导致发送错误(必要情况下才会发生)</p></li><li><p>Connecctionless 不保留连接的状况，不是从建立连接开始的。</p></li></ul></li><li><p>Transport</p><ul><li>TCP:重传,保证数据正确传输</li><li>有些不需要TCP(可靠)</li><li>UDP:不保证可靠传输</li></ul></li><li><p>Application</p><ul><li>WEB, http get,直接在应用层使用.</li><li>每一层只与另一层通信</li></ul></li></ul><h2 id="IP-网络层协议"><a href="#IP-网络层协议" class="headerlink" title="IP(网络层协议)"></a>IP(网络层协议)</h2><pre><code>- IP协议尽量把数据包传达到另一端,但不保证- IP协议可能会乱序和丢失   - 需要传输层一起工作保证不出差错- Datagrame 独立传输的数据包，由路由逐步传输- Unreliable 数据包可能被丢失- Best effort 缓存占满时丢弃数据包，错误的路由表导致发送错误(必要情况下才会发生)- Connecctionless 不保留连接的状况，不是从建立连接开始的。</code></pre><p>end-to-end principle: 如果可能，尽可能在end hosts处实现功能</p><ol><li>IP防止数据包反复循环（路由中的转发表损坏）<ol><li>报头中，TTL 从128开始，每一跳-1，归零时被路由器丢弃，可能陷入了环路</li></ol></li><li>会对数据包分段，路由器也会根据实际情况拆分数据包</li><li>使用header校验和，在报头中。减少传递到错误目的地的机会。</li><li>IP有不同的版本 IPV4 32bit， IPV6 128bit</li><li>IP允许将新字段加到header中。</li></ol><p>IPV4 Datagram()<br>版本 区分服务 分段偏移量 校验和 协议 TTL 总长度 源地址 目标地址</p><h2 id="TCP协议（传输层）"><a href="#TCP协议（传输层）" class="headerlink" title="TCP协议（传输层）"></a>TCP协议（传输层）</h2><p>IP找到机器，TCP是找到端口号向特定服务通信的。80端口一般是网页服务</p><h4 id="数据包交换原则"><a href="#数据包交换原则" class="headerlink" title="数据包交换原则"></a>数据包交换原则</h4><h4 id="分层设计原则"><a href="#分层设计原则" class="headerlink" title="分层设计原则"></a>分层设计原则</h4><h4 id="封装原则"><a href="#封装原则" class="headerlink" title="封装原则"></a>封装原则</h4><ul><li>分散了可能存在的隐患</li><li>方便复用，各组件单独工作<ul><li>应用层 message    报文</li><li>传输层 TCP segment 报文段 UDP 用户数据段</li><li>网络层 IP 数据报 datagram (IPV4 IPV6)，packet（包）</li><li>链路层：帧 framing</li><li>物理层 bit</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;可靠的双向字节流&quot;&gt;&lt;a href=&quot;#可靠的双向字节流&quot; class=&quot;headerlink&quot; title=&quot;可靠的双向字节流&quot;&gt;&lt;/a&gt;可靠的双向字节流&lt;/h2&gt;&lt;p&gt;把计算机通信简化成读、写。&lt;/p&gt;
&lt;h4 id=&quot;例1：www-http协议&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://zhaojiabei.ink/tags/CS144/"/>
    
    <category term="计网" scheme="https://zhaojiabei.ink/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
</feed>
