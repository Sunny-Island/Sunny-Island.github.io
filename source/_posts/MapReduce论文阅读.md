---
title: MapReduce论文阅读
date: 2022-4-15 18:24:22
tags: 
- 读论文
cover_picture: https://s3.bmp.ovh/imgs/2022/04/15/0cdf5b07488f985a.png
---

## 前言
MapReduce 是对大规模并行计算的抽象。为了解决多机器并行、网络通信、处理错误、提高执行效率 等通用性问题的框架内。

## 工程实现
![MR](/image/Mapreduce.png)

1. MR库首先把文件切分成块（16-64MB），之后，程序会在多个节点上启动程序的多个副本
2. 有Main节点，最为特殊。将M个Map和R个Reduce分配到其他节点上。
3. 被分配Map任务的节点读取数据，产生key/value对缓存在内存中。
4. 缓存中的数据分成R块写入磁盘。（此处会有大量shuffle，大量的小文件读写）。
5. Reduce节点接受RPC，读本地磁盘中的缓存数据，之后按Key排序。
6. 排序后传给Reduce函数。
7. Main节点管理所有的节点，和每个Map Reduce任务的进行情况。
8. Map任务产生的中间文件的位置通过Mai传n给Reduce任务。主节点要存储每个Map任务的R个文件。


## 工程优化
### 容错
#### Map崩溃
通过心跳关联所有的worker节点，同时维护所有工作的进行状态和成功状态，超时之后重新进行任务。Map产生的中间态是临时文件。


#### Reduce崩溃
恢复之后要写一个新的文件，防止与原来的文件冲突。


#### main崩溃
维护一个checkpoint，定期把状态机dump，崩溃之后从最新的checkpoint恢复。

#### 副作用
Map文件也会有冲突，需要原子性。先写到临时文件，然后一次rename原子提交该文件。

### 加速运行
网络优化：Map会发生2M次网络调用，Reduce发生M*R次网络调用，可以通过流式的方式，Map节点完成之后，Main立刻通知Reduce去拉取。


Map 和 GFS节点是同一个节点，就可以减少网络传输。


任务粒度划分。


执行任务过长，多个节点执行相同的任务，解决长尾问题。

