<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵家贝的博客</title>
  
  
  <link href="https://zhaojiabei.ink/atom.xml" rel="self"/>
  
  <link href="https://zhaojiabei.ink/"/>
  <updated>2022-04-10T07:26:21.123Z</updated>
  <id>https://zhaojiabei.ink/</id>
  
  <author>
    <name>赵家贝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bigtable论文阅读</title>
    <link href="https://zhaojiabei.ink/2022/04/10/BigTable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>https://zhaojiabei.ink/2022/04/10/BigTable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2022-04-10T13:24:22.000Z</published>
    <updated>2022-04-10T07:26:21.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Bigtable是管理大量结构化数据的分布式存储系统。是一个稀疏的、分布式的、持久化存储的多维度排序Map。<br>规模：PB级别数据，数千台机器。<br>性质：广泛应用、可扩展性、高可用，高性能，CAP？<br>不支持传统关系模型，但可以根据数据格式和部署进行动态调整（locality, 相同前缀的数据存在一起，可以做预取优化）。用户可以动态控制何时落盘，何时从磁盘读取。<br>其开源单机实现的版本是著名的leveldb。</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(row:<span class="keyword">string</span>, column:<span class="keyword">string</span>, time:<span class="keyword">int64</span>) -&gt; <span class="keyword">string</span></span><br></pre></td></tr></table></figure><h3 id="Rows"><a href="#Rows" class="headerlink" title="Rows"></a>Rows</h3><p>在单个Row下进行的读写保证是原子性的，并发更新行时方便用户编程。排序是通过对行字典序排列的。每一部分行组成tablet，是分布式存储和加载的最小单位。如果只想找几个行，就只需要几台机器的通讯就可以做到。性质相同的数据可以做连续的存储</p><h3 id="列族"><a href="#列族" class="headerlink" title="列族"></a>列族</h3><p>多个列组成的集合叫做列族。列族是访问控制的基本单位，列族层面可以控制、统计磁盘内存使用，上述的控制权限能帮助我们管理不同类型的应用：我们允许一些应用可以添加新的基本数据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数据。表可以有无限多的列，但希望只有上百个列族。同一列族下的数据往往是相同类型的，这样方便压缩。</p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>表的每一个数据都可以包含不同版本，可以通过配置列族的参数来做GC，制定保留最近的三个版本等等。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>GFS，分布式文件系统，Bigtable的表存储文件是SSTable格式的，SSTable是持久化的、排序的、不可更改的Map结构，是分块存储的，根据索引可以加载到内存。</p><p>Chubby，类似于ZK，Paxos协议，用途：</p><ul><li>选主</li><li>存储Bigtable自引导</li><li>服务发现，服务器上线下线</li><li>存储元数据，各个表的列族信息</li><li>存储访问控制列表</li></ul><h3 id="Tablet-分布"><a href="#Tablet-分布" class="headerlink" title="Tablet 分布"></a>Tablet 分布</h3><p><img src="/image/Tablet.png" alt="tablet"><br>Chubby文件，存储root tablet 信息。</p><p>root tablet，一系列元数据表中的第一个表，存其他元数据表中tablet的位置信息，不会分裂。</p><p>其他元数据表的tablet。可以索引到用户的tablet。</p><p>客户端直接跟Tablet服务器沟通，绕过master。客户端会缓存Table的位置信息，通过跟Chubby沟通得到。</p><h3 id="Tablet-分配"><a href="#Tablet-分配" class="headerlink" title="Tablet 分配"></a>Tablet 分配</h3><p>Chubby 有个文件锁，标志着该tabelt在工作，如果 Tablet 丢失了Chubby上的独占锁，就认为它已经不在工作，master会重新分配。<br>Master可以了解整个集群的数据分布，可以做负载均衡，Tablet分配，服务器加入和推出。Master发现tablet的文件锁被丢失了，就会自己去占领这个锁，判断是Chubby宕机还是服务器宕机。Tablets集合变化：增加删除，合并，分裂。</p><p>Master启动：Master获得Master锁，扫描chbby判断服务集群状态，与所有Tablet服务器通信获得Tablet分配的状态。（自引导）。<br>分裂：Tablet表太大或者访问太频繁会导致分裂。首先commit分裂操作到Metadata表中，然后通知master服务器。如果通知没成功，master会要求装载这个的子表，新的Tablet服务器加载子表的时候会查询Metadata表，发现要加载的表信息不完整，会进一步通知master。</p><h3 id="Tablet-服务"><a href="#Tablet-服务" class="headerlink" title="Tablet 服务"></a>Tablet 服务</h3><p>![tablet_server][/image/TabletRepresentation.png]<br>Tablet底层是LSM Tree。可以去看leveldb实现<br>读写操作写入WAL，数据写入内存表memtable，dump到磁盘上，<br>写操作要到Chubby鉴权，会有客户端缓存。提交之后会插入到memtable。<br>读操作要靠合并SSTable和memtable视图，合并效率很高。<br>合并和分割时，读写仍然可以进行。</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>memtable大小太大时触发压缩变成SSTable。<br>后台有合并压缩进程，定时把SSTable文件删除生成新的压缩文件。叫做主压缩。<br>定期回收内存资源和磁盘资源。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="本地化，Locality-Groups"><a href="#本地化，Locality-Groups" class="headerlink" title="本地化，Locality Groups"></a>本地化，Locality Groups</h3><p>客户端操作，可以分配不同列族到一个Locality group中，为每个group生成单独的SSTable，不关联的数据不用互相读。<br>可以指定某些数据应该被常驻在内存中。</p><h3 id="压缩-1"><a href="#压缩-1" class="headerlink" title="压缩"></a>压缩</h3><p>可以控制group的压缩算法，两端自定义压缩。</p><h3 id="读缓存"><a href="#读缓存" class="headerlink" title="读缓存"></a>读缓存</h3><p>Tablet服务器双层缓存，扫描缓存是高层缓存，缓存tablet服务器向SSTable请求得到的kv对。块缓存是底层缓存，缓存得到的SSTables块。</p><h3 id="Bloom-filters"><a href="#Bloom-filters" class="headerlink" title="Bloom filters"></a>Bloom filters</h3><p>查询某个SSTables是否含有本次需要的行列数据。</p><h3 id="Commit-日志实现"><a href="#Commit-日志实现" class="headerlink" title="Commit 日志实现"></a>Commit 日志实现</h3><p>每个Tablet一个log还是一个Tablet服务器一个log？</p><p>防止大量并发写，为每个tablet server 维护一个commit log。</p><p>使得恢复非常困难。为了解决这个问题，对log进行排序，每个tablet的mutation都是连续的，加速恢复进程。</p><p>log本身也有序列号，master负责协调。</p><h3 id="加速恢复"><a href="#加速恢复" class="headerlink" title="加速恢复"></a>加速恢复</h3><p>在下线前Server会做两次compaction，第一次完成后会停止对外服务。在加载到新的Server中，只需要读磁盘就可以了，不需要从commit log中进行恢复了。</p><h3 id="利用不可变性"><a href="#利用不可变性" class="headerlink" title="利用不可变性"></a>利用不可变性</h3><p>SSTable不可变。读SSTable不需要并发控制。GC时直接删除SSTable就可以。</p><p>memtable为了减少读竞争，设计成Copy on write。</p><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><h3 id="大的分布式系统带来各种错误"><a href="#大的分布式系统带来各种错误" class="headerlink" title="大的分布式系统带来各种错误"></a>大的分布式系统带来各种错误</h3><ul><li>内存网络</li><li>不对称的网络分区</li><li>时钟误差累计</li><li>依赖的其他服务的bug</li><li>计划和非计划的硬件维护</li></ul><h3 id="谨慎使用新特性"><a href="#谨慎使用新特性" class="headerlink" title="谨慎使用新特性"></a>谨慎使用新特性</h3><p>社区发布了新特性，要等大量测试和社区稳定，如果不是很了解就不要着急使用。</p><h3 id="系统级监控很重要"><a href="#系统级监控很重要" class="headerlink" title="系统级监控很重要"></a>系统级监控很重要</h3><h3 id="保持设计简洁"><a href="#保持设计简洁" class="headerlink" title="保持设计简洁"></a>保持设计简洁</h3><p>简单设计会带来价值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Bigtable是管理大量结构化数据的分布式存储系统。是一个稀疏的、分布式的、持久化存储的多维度排序Map。&lt;br&gt;规模：PB级别数据，数千</summary>
      
    
    
    
    
    <category term="读论文" scheme="https://zhaojiabei.ink/tags/%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>九坤并行程序优化大赛第一届经验总结</title>
    <link href="https://zhaojiabei.ink/2022/02/21/%E4%B9%9D%E5%9D%A4%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E5%A4%A7%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%B1%8A%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://zhaojiabei.ink/2022/02/21/%E4%B9%9D%E5%9D%A4%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E5%A4%A7%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%B1%8A%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
    <published>2022-02-21T20:44:40.000Z</published>
    <updated>2022-04-10T07:26:21.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="赛题背景"><a href="#赛题背景" class="headerlink" title="赛题背景"></a>赛题背景</h2><p>在赛方给定的服务器上运行winograd算法程序，以每秒浮点数计算量 GFlops 为指标评判。Winograd 算法来⾃于 CVPR 2016 的⼀篇 paper：<a href="https://arxiv.org/abs/1509.09308">Fast Algorithms for Convolutional Neural Networks。Winograd</a> 算法的主要思路便是通过减少乘法次数增多加法次数来实现提速。总体上来看这是⼀个计算密集的场景，因⽽优化便在于如果最⼤程度压榨出服务器 CPU 的性能。</p><p>服务器环境如下：</p><ul><li>CPU：Intel(R) Xeon(R) Gold 6348 CPU @ 2.60GHz</li><li>内存：768 GB</li><li>磁盘：需参照宿主机具体磁盘配置，⽂件系统为 Overlay</li></ul><p>在比赛中，我们通过分析算法特点，结合在服务器上的性能试验和队伍成员对体系结构的了解，进行了算法优化、指令级并行、数据级并行、线程级并行、编译器和内存设计等方面的优化，目的是最大限度的压榨 CPU 的运算性能。</p><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p><img src="/image/winograd.png" alt="算法"></p><p>winograd 的本质是用加法替代乘法，赛方提供的 winograd 算法是基础的 winograd(2,3) ，我们把算法扩展到了 winograd(4,3) ，同时根据<a href="https://www.researchgate.net/publication/328091476_Sparse_Winograd_Convolutional_neural_networks_on_small-scale_systolic_arrays">2018年更新的文献中</a>的方法，同时合并多个 channel 层进行计算，从而充分利用 CPU 资源。图中的算法分为Input transform、Filter transform、 Matrix Multiplication、Output transform 四个步骤，最大的改进在于同时对多个 channel 层进行分块并在一次矩阵运算中计算，从而充分利用计算能力。</p><h3 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h3><p>在编写代码的时候，我们从循环展开和减少分支预测两方面出发，进行指令级别的并行优化。循环展开主要是在矩阵运算中，因为要把两个固定大小的矩阵相乘，因此把乘法的每一步展开，有利于指令流水线的调度。</p><h3 id="数据级并行"><a href="#数据级并行" class="headerlink" title="数据级并行"></a>数据级并行</h3><p>主要采用向量化的方法，结合算法本身的特性，进行数据级并行优化。<br>单指令流多数据流（SIMD）是能够复制多个操作数，并把它们打包在⼤型寄存器的⼀组指令集。向量化计算是⼀种常⽤于加速计算密集的并⾏任务的优化⽅法。1997 年，x86 扩展出了 MMX 指令集，伴随着 8 个向量寄存器，⾸开了向量化计算的先河。之后 x86 ⼜扩展出了 SSE 和 AVX 指令集。SSE 和 AVX 各有 16 个寄存器，同⼀个寄存器可以装载多个数据单元，并且可以⽤相应的指令在同⼀个时钟周期内进⾏并⾏运算，随着指令集的升级，每个时钟周期可以并⾏的单元数也在不断增加。<br>在我们的服务器和赛⽅提供的服务器上，我们依次实验了 AVX128，AVX256 和 AVX512 指令集，另外还使用了融合乘加指令（FMA）。</p><h3 id="线程级并行"><a href="#线程级并行" class="headerlink" title="线程级并行"></a>线程级并行</h3><p>尝试通过引⼊ openmp 多线程进⾏矩阵运算，但并⾏的性能⼀直不如串⾏，甚⾄经过实验发现有线程数加倍性能减半的现象。经过分析发现在示例代码中有⼤量的⼩矩阵运算，⽐如在第⼀部分逐 channel 逐卷积核的矩阵相乘中有⼤量的⼤⼩为 4 的矩阵，矩阵太⼩导致分给每个线程的任务过少，线程本身的调度开销⼤于多线程带来的收益，因此多线程在这种运算中是⼀种负优化。为了引⼊并⾏加快速度，我们单独为中间的⼤矩阵运算编写了加⼊了多线程的函数，⼩矩阵运算则不加多线程。此优化有近 5 倍的提升。</p><p>在之后的优化中，我们放弃了自己编写矩阵乘法，通过调用MKL库来进行大矩阵的乘法操作。</p><h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><p>以上的⼯作均是在 gcc8 版本上进⾏ O3 优化测得的，⽽ gcc 截⽌今⽇的最新版本已升级为 11.2.0，可以预⻅的是，新版本的 gcc 的调优性能会更突出，为此我<br>们升级到了最新的 gcc 11.2.0 版本并继续⽤ O3 优化进⾏了测试。此⼯作提升了近 10% 的性能。</p><p>此外，我们也尝试了最新版本的 Clang/LLVM 编译器，使⽤ O3 版本编译后发现性能甚⾄不如 gcc8。虽然我们的测试不够充分，但我们猜测 LLVM 为了兼容性相<br>⽐ gcc 牺牲调了⼀定的优化空间。就如果 Java 之于 C/C++ ⼀样。</p><h3 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h3><p>本次比赛中第一次使用 perf 进行调优。通过 perf 可以直观看到代码的各个部分的运行时间，方面我们在比赛中定位瓶颈点。另外 perf 还可以看到缓存命中、流水线停顿等信息，在后期的设计中能给到很多关键的信息。</p><h3 id="比赛的不足"><a href="#比赛的不足" class="headerlink" title="比赛的不足"></a>比赛的不足</h3><p>在这次比赛中我们获得第四名，分析之下除了我们队背景知识薄弱等先天因素之外，对比获得优胜队伍的代码，我总结了这次比赛的不足之处。</p><ul><li>放弃编写自己的矩阵乘法，转而调用 MKL 库。因为队伍成员都没有 HPC 项目的经验，因此我们认为不可能编写出比库函数更好的代码。但优胜队伍都自己实现了矩阵乘法，针对这次比赛编写的乘法比我们更高效。</li><li>因为没有编写矩阵乘法，我们对缓存的控制也比优胜队伍差很多，没有进行很好的L1、L2、L3级别的缓存设计。虽然我们在内存排布中尽量把会在一次计算中用到的数据放在一起，但如果能做好缓存设计，应该会有更好的成绩。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;赛题背景&quot;&gt;&lt;a href=&quot;#赛题背景&quot; class=&quot;headerlink&quot; title=&quot;赛题背景&quot;&gt;&lt;/a&gt;赛题背景&lt;/h2&gt;&lt;p&gt;在赛方给定的服务器上运行winograd算法程序，以每秒浮点数计算量 GFlops 为指标评判。Winograd 算法来⾃于</summary>
      
    
    
    
    
    <category term="HPC" scheme="https://zhaojiabei.ink/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="https://zhaojiabei.ink/2021/10/18/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://zhaojiabei.ink/2021/10/18/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2021-10-18T20:24:22.000Z</published>
    <updated>2022-04-10T07:26:21.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器（Bloom Filter）本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0，为了将数据项添加到布隆过滤器中，我们会提供 K 个不同的哈希函数，并将结果位置上对应位的值置为 “1”。在前面所提到的哈希表中，我们使用的是单个哈希函数，因此只能输出单个索引值。而对于布隆过滤器来说，我们将使用多个哈希函数，这将会产生多个索引值。</p><p><img src="/image/bloom_filter.png" alt="test"><br>如果多个哈希值对应的位置都已经被置１，则该元素可能存在于集合中。如果有１位不符合，则说明该元素不在集合中。</p><h3 id="布隆过滤器的误判率"><a href="#布隆过滤器的误判率" class="headerlink" title="布隆过滤器的误判率"></a>布隆过滤器的误判率</h3><p>布隆过滤器的误判率由下列公式给出。<br>据此可以计算最佳函数个数，在保证误判率的情况下，布隆过滤器的位列表长度随需要被过滤的元素正比增加。<br><img src="/image/bf_false_positive.svg" alt="test"></p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>在线计算网站 <a href="https://hur.st/bloomfilter/">https://hur.st/bloomfilter/</a><br>Java库 Guava <a href="https://github.com/google/guava">https://github.com/google/guava</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;布隆过滤器&quot;&gt;&lt;a href=&quot;#布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器&quot;&gt;&lt;/a&gt;布隆过滤器&lt;/h2&gt;&lt;p&gt;布隆过滤器（Bloom Filter）本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，</summary>
      
    
    
    
    
    <category term="索引" scheme="https://zhaojiabei.ink/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>go sync常用方法</title>
    <link href="https://zhaojiabei.ink/2021/04/24/go-sync%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://zhaojiabei.ink/2021/04/24/go-sync%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2021-04-24T01:31:39.000Z</published>
    <updated>2022-04-10T07:26:21.123Z</updated>
    
    <content type="html"><![CDATA[<p>Mutex</p><p>WaitGroup</p><ul><li>Add</li><li>Done</li><li>Wait</li></ul><p>NewCond</p><ul><li>Wait</li><li>Broadcast</li></ul><p>Channel</p><ul><li>buffer</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Mutex&lt;/p&gt;
&lt;p&gt;WaitGroup&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add&lt;/li&gt;
&lt;li&gt;Done&lt;/li&gt;
&lt;li&gt;Wait&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NewCond&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wait&lt;/li&gt;
&lt;li&gt;Broadcast&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    
    <category term="go" scheme="https://zhaojiabei.ink/tags/go/"/>
    
    <category term="多线程" scheme="https://zhaojiabei.ink/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>VM-MT论文阅读</title>
    <link href="https://zhaojiabei.ink/2021/04/20/VM-MT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>https://zhaojiabei.ink/2021/04/20/VM-MT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-04-20T01:22:42.000Z</published>
    <updated>2022-04-10T07:26:21.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-design-of-a-practical-system-for-fault-tolerant-virtual-machines"><a href="#The-design-of-a-practical-system-for-fault-tolerant-virtual-machines" class="headerlink" title="The design of a practical system for fault-tolerant virtual machines"></a>The design of a practical system for fault-tolerant virtual machines</h2><h3 id="replica-备份方式"><a href="#replica-备份方式" class="headerlink" title="replica 备份方式"></a>replica 备份方式</h3><ul><li><p>传内存块过去：state transfer，以保证state的相同</p></li><li><p>传操作过去：replicated state machine，使用state transfer</p></li></ul><p>Primary/Backup</p><h3 id="机器级别vs应用程序级别"><a href="#机器级别vs应用程序级别" class="headerlink" title="机器级别vs应用程序级别"></a>机器级别vs应用程序级别</h3><p>该论文是在机器指令级别实现主从备份，现在的分布式程序往往在应用程序之间实现备份。</p><p>核心思想是让Backup像Primary一样运行，CPU指令级别上的。然后通过对于一些确定的输入，可以确定有相同的运行结果，但是对于一些不确定的事件，比如多核交互（本文只使用单核），指令中断，获取随机数，Backup需要做一些特殊处理，比如拦截中断的指令序列号让其在自己上也在特定的位置中断。</p><p>为什么指令中断会影响CPU，因为中断往往来自CPU外部，比如IO设备，时间片到期等等。</p><p>中断怎么被复制到Backup上？通过Intel CPU特定的硬件完成。</p><p>不能让从机快于主机。</p><p>由于VMM会监视输入输出，所以对于Backup机器，其输出不会被返回到客户端，只有在主机失效的时候，根据FT-protocol会切换主备份</p><h3 id="FT-Protocol"><a href="#FT-Protocol" class="headerlink" title="FT-Protocol"></a>FT-Protocol</h3><p><img src="/image/vm-ft.jpg" alt="test"></p><p>主机记录自己进行的指令操作，然后发给从机等待执行。从机会放到buffer中去等待执行，这样就防止了从机比主机快。</p><p>如果主机fail了，从机直接对外输出</p><h5 id="Output-requirement"><a href="#Output-requirement" class="headerlink" title="Output requirement"></a>Output requirement</h5><p>如果从机接管了主机，那么从机中已经被传进来的主机指令会继续执行。这样客户端就不会察觉到异常，服务会继续提供。</p><p>这条规则是为了保证指令的一致性，如果主机挂掉了，从机会保持和主机一致的行为。</p><h5 id="Output-rule"><a href="#Output-rule" class="headerlink" title="Output rule"></a>Output rule</h5><p>如果主机执行完就输出了，然后挂掉了，但还没给从机发自己执行过的指令操作，这样也会导致不一致。</p><p>因此要求主机先不急着输出自己的执行结果，先把自己的执行指令发给从机并收到了从机的回复，然后再输出结果。</p><h5 id="Test-and-set"><a href="#Test-and-set" class="headerlink" title="Test and set"></a>Test and set</h5><p>防止脑裂操作。如果主从机没法互相通信，他们就去外部服务器尝试TEST ANS SET，类似于获得锁，成功set flag的机器将成为主机。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-design-of-a-practical-system-for-fault-tolerant-virtual-machines&quot;&gt;&lt;a href=&quot;#The-design-of-a-practical-system-for-fault-tolerant-</summary>
      
    
    
    
    
    <category term="论文阅读" scheme="https://zhaojiabei.ink/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java面试问题集锦</title>
    <link href="https://zhaojiabei.ink/2021/04/14/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>https://zhaojiabei.ink/2021/04/14/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</id>
    <published>2021-04-14T09:43:24.000Z</published>
    <updated>2022-04-10T07:26:21.123Z</updated>
    
    <content type="html"><![CDATA[<p>前两天面快手问到了Java的Map问题，答得不是很好，正好此博客长期整理各种Java面试问题。</p><h4 id="1、Map-HashMap-HashTable-ConcurrentHashMap"><a href="#1、Map-HashMap-HashTable-ConcurrentHashMap" class="headerlink" title="1、Map/HashMap/HashTable/ConcurrentHashMap"></a>1、Map/HashMap/HashTable/ConcurrentHashMap</h4><p><a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464">https://blog.csdn.net/woshimaxiao1/article/details/83661464</a></p><p>模拟面试顺序： <a href="https://blog.csdn.net/weixin_35523284/article/details/112096437">https://blog.csdn.net/weixin_35523284/article/details/112096437</a></p><p>HashMap线程不安全： <a href="https://my.oschina.net/hosee/blog/673521">https://my.oschina.net/hosee/blog/673521</a></p><p>HashMap细节：<a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464">https://blog.csdn.net/woshimaxiao1/article/details/83661464</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前两天面快手问到了Java的Map问题，答得不是很好，正好此博客长期整理各种Java面试问题。&lt;/p&gt;
&lt;h4 id=&quot;1、Map-HashMap-HashTable-ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#1、Map-HashMap-HashTable-</summary>
      
    
    
    
    
    <category term="Java" scheme="https://zhaojiabei.ink/tags/Java/"/>
    
    <category term="面试准备" scheme="https://zhaojiabei.ink/tags/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>JVM面试问题集锦</title>
    <link href="https://zhaojiabei.ink/2021/03/31/JVM%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>https://zhaojiabei.ink/2021/03/31/JVM%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</id>
    <published>2021-03-31T22:50:31.000Z</published>
    <updated>2022-04-10T07:26:21.123Z</updated>
    
    <content type="html"><![CDATA[<p>前两天字节面试问到了双亲委派机制，我不知道，整理了一些JVM常见问题。</p><h4 id="0、为什么要有虚拟机（美团面试）？"><a href="#0、为什么要有虚拟机（美团面试）？" class="headerlink" title="0、为什么要有虚拟机（美团面试）？"></a>0、为什么要有虚拟机（美团面试）？</h4><p>java先编译成.class文件，然后交给不同版本的虚拟机运行。其实java只认识JVM，但JVM可以在多个不同平台上运行。实现了code once run everywhere</p><h4 id="1、介绍JVM的内存区域（运行时数据区）。-★★-P34"><a href="#1、介绍JVM的内存区域（运行时数据区）。-★★-P34" class="headerlink" title="1、介绍JVM的内存区域（运行时数据区）。 ★★ P34"></a>1、介绍JVM的内存区域（运行时数据区）。 ★★ P34</h4><p><img src="/image/JVM-memory.jpg" alt="test"></p><h5 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h5><p>线程私有，记录每个线程运行的字节码的行号。没有OOM问题</p><h5 id="虚拟机栈："><a href="#虚拟机栈：" class="headerlink" title="虚拟机栈："></a>虚拟机栈：</h5><p>每个线程运行期间自己的栈，用来存储局部变量表（基本数据类型，对象引用）、操作数栈、方法出口等信息，每一个方法被调用就是入栈到出栈的过程。方法出口：正常返回和异常返回。</p><h5 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h5><p>native方法使用的栈，执行java字节码。</p><h5 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h5><p>线程共享，GC管理的区域，存放对象实例。堆会被细分位多个线程私有的分配缓冲区，提升分配效率。目的是为了更好回收内存</p><h5 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h5><p>线程共享，存储已经被加载的类型信息、常量、静态变量。可以选择不GC，但并不意味这这是永久区。</p><p>运行时常量池：是方法区的一部分。Class文件中有存放编译期生成的各种字面量和符号引用，在类加载后放在方法区的运行时常量池中。具有动态性</p><h4 id="2、如何判断对象已经死亡？-★★P69"><a href="#2、如何判断对象已经死亡？-★★P69" class="headerlink" title="2、如何判断对象已经死亡？ ★★P69"></a>2、如何判断对象已经死亡？ ★★P69</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>维护一个对象的引用计数器，被引用+1，引用失效-1，当归零时意味着对象已经死亡。该方法简单高效但有循环引用问题，比如AB相互引用则AB都不会被GC。java虚拟机并不是采用这种方法来判断对象是否存活的。</p><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>以GC ROOT对象作为根根据引用关系向下搜索，没有引用链相连的对象判定为不可达。</p><p>可以作为GC root：</p><ul><li><p>虚拟机栈中各个线程被调用的方法堆栈中使用的参数、局部变量和临时变量等。这意味着他们正在被调用</p></li><li><p>方法区中类静态属性引用的对象，引用类型静态变量</p></li><li><p>方法区中常量引用的对象：比如字符串常量池，初始化字符串时先去常量池中看一下是不是有该字符串，有则返回引用即可</p></li><li><p>本地方法栈中的对象</p></li><li><p>java虚拟机内部的对象，比如长用数据类型对应的class，常驻的异常对象等等。</p></li><li><p>所有被同步锁持有的对象</p></li></ul><h5 id="引用类型的分类"><a href="#引用类型的分类" class="headerlink" title="引用类型的分类"></a>引用类型的分类</h5><p>传统来说，如果引用指向的地址是另一个内存的起始地址，它就是引用。但有些对象希望尽可能不被收集（缓存功能），只要系统内存还够。因此之后java添加了四种引用</p><h4 id="3、简述强、软、弱、虚引用。-★"><a href="#3、简述强、软、弱、虚引用。-★" class="headerlink" title="3、简述强、软、弱、虚引用。 ★"></a>3、简述强、软、弱、虚引用。 ★</h4><ul><li>强引用：传统引用的概念</li><li>软引用SoftReference如果要OOM了就把这些对象回收了，内存还是不够就OOM</li><li>弱引用WeakReference。只能生存到下一次GC，如果GC开始工作就会把这部分回收掉</li><li>虚引用PhantomReference让对象被回收时能收到系统通知。</li></ul><h4 id="4、简述垃圾收集算法以及各自特点。-★★…-25"><a href="#4、简述垃圾收集算法以及各自特点。-★★…-25" class="headerlink" title="4、简述垃圾收集算法以及各自特点。 ★★… 25"></a>4、简述垃圾收集算法以及各自特点。 ★★… 25</h4><h5 id="分代收集假说："><a href="#分代收集假说：" class="headerlink" title="分代收集假说："></a>分代收集假说：</h5><ul><li>老年代的对象大概率不会被回收</li><li>绝大多数对象很快被回收，新生代的对象大概率（95%）会被回收</li><li>跨代引用很稀少<h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5>产生大量的内存碎片，因为需要清除的对象太多导致算法效率很差<h5 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h5>适合新生代，因为大部分不需要复制。<br>内存空间分为1个Eden和2个Survivor空间，每次预留空间的10%用作复制用。<br>存在逃生门的安全设计，如果Survivor空间不够用则会占用老生代的内存空间复制对象<br>这种机制叫做分配担保<h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5>适合老年代，100%对象都存活的极限情况。需要移动对象。老年代对象很多负担很大。<br>移动对象则会导致回收复杂，不移动对象则会使内存分配更复杂，有利于整个程序的吞吐量。<br>内存分配的频率比垃圾收集要高得多，因此HotSpot中关注吞吐量的Parallel Old 收集器是标记整理，关注延迟的CMS使用的是多次标记清除知道内存过于碎片化，再用标记整理算法收集一次。</li></ul><p>缓存行伪共享问题: <a href="https://www.cnblogs.com/cyfonly/p/5800758.html">https://www.cnblogs.com/cyfonly/p/5800758.html</a></p><h4 id="5、常见的垃圾收集器有哪些。-★★…-26"><a href="#5、常见的垃圾收集器有哪些。-★★…-26" class="headerlink" title="5、常见的垃圾收集器有哪些。 ★★… 26"></a>5、常见的垃圾收集器有哪些。 ★★… 26</h4><p>不可能三角：内存占用量，吞吐率，延迟<br>按时间顺序</p><h5 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h5><p>单线程效率高，新生代，标记-复制，占用内存小，适合在客户端<br>Serial Old</p><h5 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h5><p>Serial 多线程，任需要停止客户端服务</p><h5 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h5><p>基于标记-清除<br>实现并发<br>初始标记 并发标记 重新标记 并发清除，采用增量更新保证并发<br>容易出现浮动垃圾，运行期间可能导致内存不足，没过N次需要标记整理</p><h5 id="Parallel-Scavenge-Old"><a href="#Parallel-Scavenge-Old" class="headerlink" title="Parallel Scavenge/Old"></a>Parallel Scavenge/Old</h5><p>关注吞吐量，标记复制-标记整理，争取让代码运行时间更长一些。</p><h5 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h5><p>Region based<br>复制整理后的Region到新Region<br>通过STAB实现并发,两个指针TAMS保证新分配的对象<br>根据优先级队列判断回收哪个region<br>卡表更加复杂，双向卡表，维护时间长<br>不会产生内存碎片<br>可以追求低延迟也可以追求高吞吐量</p><h5 id="低延迟：Shenandoah-ZGC"><a href="#低延迟：Shenandoah-ZGC" class="headerlink" title="低延迟：Shenandoah ZGC"></a>低延迟：Shenandoah ZGC</h5><p>通过连接矩阵<br>通过转发指针和读屏障实现并发<br>ZGC通过染色指针技术</p><h4 id="6、吞吐量优先和响应优先的垃圾收集器如何选择？…-27"><a href="#6、吞吐量优先和响应优先的垃圾收集器如何选择？…-27" class="headerlink" title="6、吞吐量优先和响应优先的垃圾收集器如何选择？… 27"></a>6、吞吐量优先和响应优先的垃圾收集器如何选择？… 27</h4><p>吞吐量优先：Parallel Scavenge/Old<br>响应优先：Shenandoah ZGC<br>版本问题&amp;&amp;堆内存大小综合考虑：G1 CMS</p><h4 id="7、内存分配与回收策略。（对象何时进行老年代？）-★…-27"><a href="#7、内存分配与回收策略。（对象何时进行老年代？）-★…-27" class="headerlink" title="7、内存分配与回收策略。（对象何时进行老年代？） ★… 27"></a>7、内存分配与回收策略。（对象何时进行老年代？） ★… 27</h4><p>基于标志-复制算法<br>优先在Eden区分配 0岁<br>活过一次GC Survivor 1岁<br>15岁到老年代，或者动态判定<br>大对象直接分配到老年代</p><p>8、虚拟机性能监控和故障处理工具 ★… 28</p><p>9、Class类文件的结构。… 28</p><p>10、简述JVM中的类加载机制。★… 28</p><p>11、简述JVM中的类加载器以及双亲委派模型。 ★★… 29</p><p>12、简述JVM中静态分派和动态分派（重载和重写）。… 30</p><p>13、jvm启动模式之client与server（蚂蚁金服）… 30</p><p>14、如何优化Java GC（蚂蚁金服） ★… 30</p><p>15、JVM进程有哪些线程启动？（拼多多）… 31</p><p>16、Java 8的metaspace（元空间）… <strong>31</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前两天字节面试问到了双亲委派机制，我不知道，整理了一些JVM常见问题。&lt;/p&gt;
&lt;h4 id=&quot;0、为什么要有虚拟机（美团面试）？&quot;&gt;&lt;a href=&quot;#0、为什么要有虚拟机（美团面试）？&quot; class=&quot;headerlink&quot; title=&quot;0、为什么要有虚拟机（美团面试</summary>
      
    
    
    
    
    <category term="JVM" scheme="https://zhaojiabei.ink/tags/JVM/"/>
    
    <category term="Java" scheme="https://zhaojiabei.ink/tags/Java/"/>
    
    <category term="面试准备" scheme="https://zhaojiabei.ink/tags/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>CS144笔记(3)</title>
    <link href="https://zhaojiabei.ink/2021/03/30/CS144%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <id>https://zhaojiabei.ink/2021/03/30/CS144%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/</id>
    <published>2021-03-30T11:01:29.000Z</published>
    <updated>2022-04-10T07:26:21.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>可靠的，端到端的传输协议。<br>双向通信=连接。在两端TCP会留下一个状态机。<br>三次握手建立TCP<br>A:Syn<br>B:Syn+Ack<br>A:Ack<br>TCP:stream of bytes service<br>A将数据传入TCP segment，B从segment中解析交给应用程序。<br>可能被多次传输。<br>最小1byte比如ssh<br>发送大量数据：填满segment知道最大IP数据包<br>四次挥手关闭TCP<br>TCP的服务特点：</p><ul><li><p>Stream of bytes:可靠的字节流传输</p></li><li><p>Reliable delivery:</p><ul><li>收到信息会发送acknowledgments（ack）表示信息已经被接受</li><li>checksum校验和检查是否有脏数据（每个segment都有）</li><li>序列号检查是否有遗漏数据（segment lost）</li><li>flow control防止接收方被淹没，接收方有空间则多发，没空间就少发</li></ul></li><li><p>In sequence: TCP层会对收到的数据进行重新排序使之有序。</p></li><li><p>Congestion Control</p></li></ul><p>为了实现上述的功能，TCP的header比较复杂。</p><p>destination port,source port：把同一台主机的不同TCP连接区分开</p><p>sequence number: first byte，下一个number则是上一个number+上一个length</p><p>acknowledgement sequence: 当前接收到哪个字节</p><p>flag位，建立连接和断开会用到ack, fin, syn 等等，还有psh要求立刻发送数据</p><p>常见端口号：</p><p>21 FTP</p><p>22 SSH</p><p>23 smtp</p><p>80 HTTP</p><p>443 HTTPS</p><p>1433 MSSQLserver</p><p>3306 MySQL</p><p>11211 memcached</p><p>IP中明确告诉我们使用的协议是TCP，通过端口号就可以找到对应的TCP连接。</p><p>TCP还有重传，并且利用滑动窗口来做flow control。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>应用程序不需要可靠，或者自己处理重传。<br>非常简单。标头只有4个<br>Source port, destination port<br>checksum,length<br>checksum 包含ip header<br>UDP信息可能被交付也可能不被交付。<br>UDP的服务特点：</p><ul><li><p>没有连接，数据包传输顺序不确定</p></li><li><p>不可靠。没有确认，没有探测乱序或者丢失的服务<br>有点像IP的服务。不提供交付保证。<br>应用:DNS,快速高效。</p></li></ul><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>IP， Routing Tables， ICMP 构成了网络层<br>作错误报告，路由器处理包出了意外，用于向数据源发消息，找出数据包经过的路径。<br>属于传输层协议。<br>不可靠，用于指出问题，不会重发<br>依赖于IP层传输<br>ICMP的一个重要应用：ping，traceroter</p><h2 id="End-to-end-principle"><a href="#End-to-end-principle" class="headerlink" title="End to end principle"></a>End to end principle</h2><p>为什么提供这种服务，而不采取更多服务的提供，比如压缩合并文件。</p><h2 id="Error-Detection"><a href="#Error-Detection" class="headerlink" title="Error Detection"></a>Error Detection</h2><p>校验和 循环冗余码CRC 消息认证码MAC<br>不同层使用不同的方法，结合在一起使得网络的传输错误率非常低。</p><h3 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h3><p>不可靠，简单，两个错码可能相互抵消<br>IP/TCP层使用</p><h3 id="Cycli-redundancy-code"><a href="#Cycli-redundancy-code" class="headerlink" title="Cycli redundancy code"></a>Cycli redundancy code</h3><p>消耗较大，可以避免很多错误，c位校验码可以检验c位以下的所有错误。<br>在链路层常常使用，可以利用硬件快速计算。</p><h3 id="Message-authentication-code"><a href="#Message-authentication-code" class="headerlink" title="Message authentication code"></a>Message authentication code</h3><p>鲁棒性强，可以抵抗恶意信息。<br>TLS层使用（应用层）</p><h2 id="Finite-State-Machines"><a href="#Finite-State-Machines" class="headerlink" title="Finite State Machines"></a>Finite State Machines</h2><p>比如TCP三次握手的时候会用到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;TCP&quot;&gt;&lt;/a&gt;TCP&lt;/h2&gt;&lt;p&gt;可靠的，端到端的传输协议。&lt;br&gt;双向通信=连接。在两端TCP会留下一个状态机。&lt;br&gt;三次握手建立TCP&lt;br&gt;A:Syn&lt;br&gt;</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://zhaojiabei.ink/tags/CS144/"/>
    
    <category term="计网" scheme="https://zhaojiabei.ink/tags/%E8%AE%A1%E7%BD%91/"/>
    
    <category term="TCP" scheme="https://zhaojiabei.ink/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>哈希小知识</title>
    <link href="https://zhaojiabei.ink/2021/03/13/%E5%93%88%E5%B8%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>https://zhaojiabei.ink/2021/03/13/%E5%93%88%E5%B8%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/</id>
    <published>2021-03-13T21:04:20.000Z</published>
    <updated>2022-04-10T07:26:21.123Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hash散列函数为什么要对素数取余"><a href="#Hash散列函数为什么要对素数取余" class="headerlink" title="Hash散列函数为什么要对素数取余"></a>Hash散列函数为什么要对素数取余</h3><p>假设散列函数是<br>$$<br>hash(key) = key % M= key-xm\<br>$$<br>假设key和M有公约数g<br>$$<br>key = ag,m =bg\<br>hash(key)=key-xm = key-[\frac{a}{b}]m\<br>0\le \frac{a}{b}\le a<br>$$<br>显然$hash(key)$的取值只有$a+1$种可能，在[0, m-1]上就不是均匀分布了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Hash散列函数为什么要对素数取余&quot;&gt;&lt;a href=&quot;#Hash散列函数为什么要对素数取余&quot; class=&quot;headerlink&quot; title=&quot;Hash散列函数为什么要对素数取余&quot;&gt;&lt;/a&gt;Hash散列函数为什么要对素数取余&lt;/h3&gt;&lt;p&gt;假设散列函数是&lt;br</summary>
      
    
    
    
    
    <category term="Hash" scheme="https://zhaojiabei.ink/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>CS144笔记(2)</title>
    <link href="https://zhaojiabei.ink/2021/03/12/CS144%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>https://zhaojiabei.ink/2021/03/12/CS144%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</id>
    <published>2021-03-12T16:46:31.000Z</published>
    <updated>2022-04-10T07:26:21.123Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>计算机要把信息写到内存中，然后再通过网络发送消息。计算机之间要统一格式，方便阅读这些消息。</p><h3 id="Byte-Order"><a href="#Byte-Order" class="headerlink" title="Byte Order"></a>Byte Order</h3><p>Little endian: 对计算机更有效</p><p>Big endian: 方便人类阅读<br>协议选择一个：Internet都选择了Bigendian<br>但是处理器是little endian，很难受<br>host&amp;&amp;network的顺序<br>host和network之间要转换，注意这一点。network选择了Bigendian</p><h3 id="Packet-Formats-IP-网络层"><a href="#Packet-Formats-IP-网络层" class="headerlink" title="Packet Formats(IP 网络层)"></a>Packet Formats(IP 网络层)</h3><p>IPV4长度是16，4个16进制数，最长是2^16<br>有目标地址，源地址<br>需要独立的，唯一的地址<br>地址长度32bits，4个八位数字<br>子网掩码：划分网路号和机器号<br>子网掩码前x是1，后32-x是0，对IP地址做与运算，结果相同的是同一个机器<br>同一个IP经过不同的子网掩码会划分出不同的机器号和网络号<br>前缀的设置涉及到子网划分<br>需要的地址块必须是2的整数幂，而且有对其要求（位于字节边界上）</p><p>三类地址划分。随着主机增加，这类方法显得很粗糙</p><h4 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h4><p>把多个具有相同前缀的地址块聚合成一个大的地址块（路由聚合）</p><p>避免了路由信息爆炸。</p><p>路由聚合和子网划分可以协同工作。</p><p>当一个数据包到达时，路由器做最长前缀匹配，发送。</p><h4 id="Longest-prefix-match"><a href="#Longest-prefix-match" class="headerlink" title="Longest prefix match"></a>Longest prefix match</h4><p>路由器选择发送的链路<br>171.33.x.x match 171.33.5.245 and 171.33.1.1<br>如果匹配不到，选择默认链路<br>路由器有转发表，包含CIDR条目和对应的下一跳link<br>/x 越短，匹配的IP范围更广泛</p><h4 id="Address-Resolution-Protocol"><a href="#Address-Resolution-Protocol" class="headerlink" title="Address Resolution Protocol"></a>Address Resolution Protocol</h4><p>设备有IP地址，网络层需要通过IP地址找到具体的下一跳的链接地址。IP是网络级地址，link address 描述了特定的网卡，接受链路层的帧。即 以太网地址。<br>购买网卡可以获得唯一的以太网地址。<br>总之就是IP是网络层的，链路层需要自己的具体地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Memory&quot;&gt;&lt;a href=&quot;#Memory&quot; class=&quot;headerlink&quot; title=&quot;Memory&quot;&gt;&lt;/a&gt;Memory&lt;/h3&gt;&lt;p&gt;计算机要把信息写到内存中，然后再通过网络发送消息。计算机之间要统一格式，方便阅读这些消息。&lt;/p&gt;
&lt;h3 </summary>
      
    
    
    
    
    <category term="CS144" scheme="https://zhaojiabei.ink/tags/CS144/"/>
    
    <category term="计网" scheme="https://zhaojiabei.ink/tags/%E8%AE%A1%E7%BD%91/"/>
    
    <category term="IPv4" scheme="https://zhaojiabei.ink/tags/IPv4/"/>
    
  </entry>
  
  <entry>
    <title>CS144笔记（1）</title>
    <link href="https://zhaojiabei.ink/2021/03/02/CS144%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://zhaojiabei.ink/2021/03/02/CS144%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
    <published>2021-03-02T15:01:23.000Z</published>
    <updated>2022-04-10T07:26:21.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可靠的双向字节流"><a href="#可靠的双向字节流" class="headerlink" title="可靠的双向字节流"></a>可靠的双向字节流</h2><p>把计算机通信简化成读、写。</p><h4 id="例1：www-http协议"><a href="#例1：www-http协议" class="headerlink" title="例1：www (http协议)"></a>例1：www (http协议)</h4><ul><li>http协议以文件为中心，Clinet向Server发送请求（GET），得到root page和一个状态码（比如200成功码，400失败码）</li><li>http是人类可以理解的ASCII文本</li></ul><h4 id="例2：bit"><a href="#例2：bit" class="headerlink" title="例2：bit"></a>例2：bit</h4><ul><li><p>Bit Torrent breaks files into pieces</p></li><li><p>clients join and leave swarms</p></li><li><p>以<strong>种子</strong>文件为起点，通过http下载。</p><ul><li>描述了tracker的信息</li></ul></li><li><p>Tracker跟踪所有客户端成员</p></li><li><p>Client向Tracker请求客户端列表，并向这些客户端请求数据。</p></li></ul><h4 id="Skype"><a href="#Skype" class="headerlink" title="Skype"></a>Skype</h4><ul><li>NAT:如果你在NAT之后，你可以打开其他连接，但其他Clinet不能随意打开你。个人计算机通常位于NAT之后</li><li>集合服务器(Rendezvous)<ul><li>A在NAT后，B不在。B请求rendezvous，rendezvous请求A，A请求B建立连接。最终的结果是A向B发起连接，所以叫反向连接、</li></ul></li><li>中继服务器(Relay)<ul><li>Relay向A和B转发数据。</li></ul></li></ul><h2 id="四层网络模型"><a href="#四层网络模型" class="headerlink" title="四层网络模型"></a>四层网络模型</h2><p>分层设计思想：<br>    - Application<br>    - Transport<br>    - Network<br>    - Link</p><ul><li><p>Link</p><ul><li><pre><code>网络组成：links hosts routers</code></pre></li><li><pre><code>数据链路层的工作是一次通过一个链路传输数据</code></pre></li><li><pre><code>常见的连接：以太网、wifi</code></pre></li><li><pre><code>传输帧</code></pre></li></ul></li><li><p>Network</p><ul><li>最重要的一层</li><li>收到Link的信息，并通过router告诉Link下一跳的地址</li><li>传输包packet data+header</li></ul></li><li><p>IP(网络层协议)</p><ul><li><p>IP协议尽量把数据包传达到另一端,但不保证</p></li><li><p>IP协议可能会乱序和丢失</p><ul><li>需要传输层一起工作保证不出差错</li></ul></li><li><p>Datagrame 独立传输的数据包，由路由逐步传输</p></li><li><p>Unreliable 数据包可能被丢失</p></li><li><p>Best effort 缓存占满时丢弃数据包，错误的路由表导致发送错误(必要情况下才会发生)</p></li><li><p>Connecctionless 不保留连接的状况，不是从建立连接开始的。</p></li></ul></li><li><p>Transport</p><ul><li>TCP:重传,保证数据正确传输</li><li>有些不需要TCP(可靠)</li><li>UDP:不保证可靠传输</li></ul></li><li><p>Application</p><ul><li>WEB, http get,直接在应用层使用.</li><li>每一层只与另一层通信</li></ul></li></ul><h2 id="IP-网络层协议"><a href="#IP-网络层协议" class="headerlink" title="IP(网络层协议)"></a>IP(网络层协议)</h2><pre><code>- IP协议尽量把数据包传达到另一端,但不保证- IP协议可能会乱序和丢失   - 需要传输层一起工作保证不出差错- Datagrame 独立传输的数据包，由路由逐步传输- Unreliable 数据包可能被丢失- Best effort 缓存占满时丢弃数据包，错误的路由表导致发送错误(必要情况下才会发生)- Connecctionless 不保留连接的状况，不是从建立连接开始的。</code></pre><p>end-to-end principle: 如果可能，尽可能在end hosts处实现功能</p><ol><li>IP防止数据包反复循环（路由中的转发表损坏）<ol><li>报头中，TTL 从128开始，每一跳-1，归零时被路由器丢弃，可能陷入了环路</li></ol></li><li>会对数据包分段，路由器也会根据实际情况拆分数据包</li><li>使用header校验和，在报头中。减少传递到错误目的地的机会。</li><li>IP有不同的版本 IPV4 32bit， IPV6 128bit</li><li>IP允许将新字段加到header中。</li></ol><p>IPV4 Datagram()<br>版本 区分服务 分段偏移量 校验和 协议 TTL 总长度 源地址 目标地址</p><h2 id="TCP协议（传输层）"><a href="#TCP协议（传输层）" class="headerlink" title="TCP协议（传输层）"></a>TCP协议（传输层）</h2><p>IP找到机器，TCP是找到端口号向特定服务通信的。80端口一般是网页服务</p><h4 id="数据包交换原则"><a href="#数据包交换原则" class="headerlink" title="数据包交换原则"></a>数据包交换原则</h4><h4 id="分层设计原则"><a href="#分层设计原则" class="headerlink" title="分层设计原则"></a>分层设计原则</h4><h4 id="封装原则"><a href="#封装原则" class="headerlink" title="封装原则"></a>封装原则</h4><ul><li>分散了可能存在的隐患</li><li>方便复用，各组件单独工作<ul><li>应用层 message    报文</li><li>传输层 TCP segment 报文段 UDP 用户数据段</li><li>网络层 IP 数据报 datagram (IPV4 IPV6)，packet（包）</li><li>链路层：帧 framing</li><li>物理层 bit</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;可靠的双向字节流&quot;&gt;&lt;a href=&quot;#可靠的双向字节流&quot; class=&quot;headerlink&quot; title=&quot;可靠的双向字节流&quot;&gt;&lt;/a&gt;可靠的双向字节流&lt;/h2&gt;&lt;p&gt;把计算机通信简化成读、写。&lt;/p&gt;
&lt;h4 id=&quot;例1：www-http协议&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://zhaojiabei.ink/tags/CS144/"/>
    
    <category term="计网" scheme="https://zhaojiabei.ink/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
</feed>
