---
title: 九坤并行程序优化大赛第一届经验总结
date: 2022-02-21 20:44:40
tags: 
- HPC
cover_picture: images/winograd.png
---

## 赛题背景

在赛方给定的服务器上运行winograd算法程序，以每秒浮点数计算量 GFlops 为指标评判。Winograd 算法来⾃于 CVPR 2016 的⼀篇 paper：[Fast Algorithms for Convolutional Neural Networks。Winograd](https://arxiv.org/abs/1509.09308) 算法的主要思路便是通过减少乘法次数增多加法次数来实现提速。总体上来看这是⼀个计算密集的场景，因⽽优化便在于如果最⼤程度压榨出服务器 CPU 的性能。

服务器环境如下：
* CPU：Intel(R) Xeon(R) Gold 6348 CPU @ 2.60GHz
* 内存：768 GB
* 磁盘：需参照宿主机具体磁盘配置，⽂件系统为 Overlay

在比赛中，我们通过分析算法特点，结合在服务器上的性能试验和队伍成员对体系结构的了解，进行了算法优化、指令级并行、数据级并行、线程级并行、编译器和内存设计等方面的优化，目的是最大限度的压榨 CPU 的运算性能。

### 算法优化

![算法](/image/bloom_filter.png )

winograd 的本质是用加法替代乘法，赛方提供的 winograd 算法是基础的 winograd(2,3) ，我们把算法扩展到了 winograd(4,3) ，同时根据[2018年更新的文献中](https://www.researchgate.net/publication/328091476_Sparse_Winograd_Convolutional_neural_networks_on_small-scale_systolic_arrays)的方法，同时合并多个 channel 层进行计算，从而充分利用 CPU 资源。图中的算法分为Input transform、Filter transform、 Matrix Multiplication、Output transform 四个步骤，最大的改进在于同时对多个 channel 层进行分块并在一次矩阵运算中计算，从而充分利用计算能力。


### 指令级并行

在编写代码的时候，我们从循环展开和减少分支预测两方面出发，进行指令级别的并行优化。循环展开主要是在矩阵运算中，因为要把两个固定大小的矩阵相乘，因此把乘法的每一步展开，有利于指令流水线的调度。


### 数据级并行

主要采用向量化的方法，结合算法本身的特性，进行数据级并行优化。
单指令流多数据流（SIMD）是能够复制多个操作数，并把它们打包在⼤型寄存器的⼀组指令集。向量化计算是⼀种常⽤于加速计算密集的并⾏任务的优化⽅法。1997 年，x86 扩展出了 MMX 指令集，伴随着 8 个向量寄存器，⾸开了向量化计算的先河。之后 x86 ⼜扩展出了 SSE 和 AVX 指令集。SSE 和 AVX 各有 16 个寄存器，同⼀个寄存器可以装载多个数据单元，并且可以⽤相应的指令在同⼀个时钟周期内进⾏并⾏运算，随着指令集的升级，每个时钟周期可以并⾏的单元数也在不断增加。
在我们的服务器和赛⽅提供的服务器上，我们依次实验了 AVX128，AVX256 和 AVX512 指令集，另外还使用了融合乘加指令（FMA）。

### 线程级并行

尝试通过引⼊ openmp 多线程进⾏矩阵运算，但并⾏的性能⼀直不如串⾏，甚⾄经过实验发现有线程数加倍性能减半的现象。经过分析发现在示例代码中有⼤量的⼩矩阵运算，⽐如在第⼀部分逐 channel 逐卷积核的矩阵相乘中有⼤量的⼤⼩为 4 的矩阵，矩阵太⼩导致分给每个线程的任务过少，线程本身的调度开销⼤于多线程带来的收益，因此多线程在这种运算中是⼀种负优化。为了引⼊并⾏加快速度，我们单独为中间的⼤矩阵运算编写了加⼊了多线程的函数，⼩矩阵运算则不加多线程。此优化有近 5 倍的提升。

在之后的优化中，我们放弃了自己编写矩阵乘法，通过调用MKL库来进行大矩阵的乘法操作。


### 编译器优化

以上的⼯作均是在 gcc8 版本上进⾏ O3 优化测得的，⽽ gcc 截⽌今⽇的最新版本已升级为 11.2.0，可以预⻅的是，新版本的 gcc 的调优性能会更突出，为此我
们升级到了最新的 gcc 11.2.0 版本并继续⽤ O3 优化进⾏了测试。此⼯作提升了近 10% 的性能。


此外，我们也尝试了最新版本的 Clang/LLVM 编译器，使⽤ O3 版本编译后发现性能甚⾄不如 gcc8。虽然我们的测试不够充分，但我们猜测 LLVM 为了兼容性相
⽐ gcc 牺牲调了⼀定的优化空间。就如果 Java 之于 C/C++ ⼀样。


### Profile
本次比赛中第一次使用 perf 进行调优。通过 perf 可以直观看到代码的各个部分的运行时间，方面我们在比赛中定位瓶颈点。另外 perf 还可以看到缓存命中、流水线停顿等信息，在后期的设计中能给到很多关键的信息。


### 比赛的不足

在这次比赛中我们获得第四名，分析之下除了我们队背景知识薄弱等先天因素之外，对比获得优胜队伍的代码，我总结了这次比赛的不足之处。
* 放弃编写自己的矩阵乘法，转而调用 MKL 库。因为队伍成员都没有 HPC 项目的经验，因此我们认为不可能编写出比库函数更好的代码。但优胜队伍都自己实现了矩阵乘法，针对这次比赛编写的乘法比我们更高效。
* 因为没有编写矩阵乘法，我们对缓存的控制也比优胜队伍差很多，没有进行很好的L1、L2、L3级别的缓存设计。虽然我们在内存排布中尽量把会在一次计算中用到的数据放在一起，但如果能做好缓存设计，应该会有更好的成绩。
